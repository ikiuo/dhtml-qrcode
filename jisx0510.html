<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>QRコードの画像作成</title>
    <style>
      body {
          margin-left: auto;
          margin-right: auto;
          width: 750px;
      }
      table {
          border: solid 1px gray;
          border-collaspe: collaspe;
          border-spacing: 0;
      }
      th, td {
          border: solid 1px gray;
          padding: 4px;
      }
    </style>
  </head>
  <body>
    <h1>QRコードの画像作成</h1>
    <hr>
    <div>&nbsp;</div>
    <table>
      <tr>
        <td>入力</td>
        <td><textarea id="qrinp" rows="12" cols="80" oninput="onUpdate()"></textarea></td>
      </tr>
      <tr>
        <td>調査</td>
        <td id="error">&nbsp;</td>
      </tr>
      <tr>
        <td colspan="2">
          <small>※色違い文字へのECIモード指定により、対応が不十分なリーダーでは読み取れないことがあります。</small>
        </td>
      </tr>
    </table>
    <p>
      <input type="checkbox" class="micro" id="micro" name="micro" />
      <label for="micro">マイクロ QR コードを使用する</label>
      |
      <label for="scale">拡大率</label>
      <input type="number" id="scale" name="scale"
             min="1" max="10" step="1" value="2"
             oninput="onUpdate()" />
      <!-- ***** 規定の拡大率は「value="2"」の部分です ***** -->
    </p>
    <small>
      <ul>
	<li>国際規格では、既定の文字セットを「ISO 8859-1」として処理します</li>
	<li>日本産業規格では、既定の文字セットを「シフトJIS」として処理します</li>
	<li>文字セットがリーダーの規定と異なる場合は文字化けすることがあります</li>
	<li>シンボル周囲の余白（4モジュール分）はリーダー向けなので削らないでください</li>
	<li>誤り訂正はレベル L,M,Q,H の順にQRコードの損壊に対して強くなります</li>
      </ul>
    </small>
    <table>
      <tr>
        <th rowspan="2"><small>誤り訂正<br/>レベル</small></th>
        <th rowspan="2"><small>復元<br/>能力<br/>(概数)</small></th>
        <th colspan="3">国際規格(ISO)</th>
        <th colspan="3">日本産業規格(JIS)</th>
      </tr>
      <tr>
        <th>&nbsp;型&nbsp;</th>
        <th>&nbsp;&nbsp;サイズ&nbsp;&nbsp;</th>
        <th>QR コード</th>
        <th>&nbsp;型&nbsp;</th>
        <th>&nbsp;&nbsp;サイズ&nbsp;&nbsp;</th>
        <th>QR コード</th>
      </tr>
      <tr hidden id="m1tr">
        <th><small>誤り検出<br/>のみ</small></th>
        <td style="text-align: right;">0%</td>
        <td style="text-align: center;" id="iqrtype0"></td>
        <td style="text-align: center;" id="iqrsize0"></td>
        <td style="text-align: center;" id="icorrect0"></td>
        <td style="text-align: center;" id="jqrtype0"></td>
        <td style="text-align: center;" id="jqrsize0"></td>
        <td style="text-align: center;" id="jcorrect0"></td>
      </tr>
      <tr>
        <th>L</th>
        <td style="text-align: right;">7%</td>
        <td style="text-align: center;" id="iqrtype1"></td>
        <td style="text-align: center;" id="iqrsize1"></td>
        <td style="text-align: center;" id="icorrect1"></td>
        <td style="text-align: center;" id="jqrtype1"></td>
        <td style="text-align: center;" id="jqrsize1"></td>
        <td style="text-align: center;" id="jcorrect1"></td>
      </tr>
      <tr>
        <th>M</th>
        <td style="text-align: right;">15%</td>
        <td style="text-align: center;" id="iqrtype2"></td>
        <td style="text-align: center;" id="iqrsize2"></td>
        <td style="text-align: center;" id="icorrect2"></td>
        <td style="text-align: center;" id="jqrtype2"></td>
        <td style="text-align: center;" id="jqrsize2"></td>
        <td style="text-align: center;" id="jcorrect2"></td>
      </tr>
      <tr>
        <th>Q</th>
        <td style="text-align: right;">25%</td>
        <td style="text-align: center;" id="iqrtype3"></td>
        <td style="text-align: center;" id="iqrsize3"></td>
        <td style="text-align: center;" id="icorrect3"></td>
        <td style="text-align: center;" id="jqrtype3"></td>
        <td style="text-align: center;" id="jqrsize3"></td>
        <td style="text-align: center;" id="jcorrect3"></td>
      </tr>
      <tr>
        <th>H</th>
        <td style="text-align: right;">30%</td>
        <td style="text-align: center;" id="iqrtype4"></td>
        <td style="text-align: center;" id="iqrsize4"></td>
        <td style="text-align: center;" id="icorrect4"></td>
        <td style="text-align: center;" id="jqrtype4"></td>
        <td style="text-align: center;" id="jqrsize4"></td>
        <td style="text-align: center;" id="jcorrect4"></td>
      </tr>
    </table>
    <div>&nbsp;</div>
    <hr>
    <small>
      <p>「QRコード」は㈱デンソーウェーブの登録商標です。</p>
    </small>

    <script type="text/javascript">

      /* **************************************** */
      /*
       * QR コード メッセージ処理
       */

      class GenQRCode {
          // コンストラクタ.
          constructor(message) {
              const Type = GenQRCodeType;
              const Matrix = GenQRCodeMatrix;
              this.Type = Type;
              this.Matrix = Matrix;
              this.message = message;
              this.autoEncodeMessage = [];
              this.autoEncodeImage = [];
          }

          // 型と誤り訂正レベルのイメージ一覧を生成する
          autoEncode(option, scale) {
              const autoencmsg = this.Type.autoEncodeMessage(this.message, option);
              const image = [];
              for (let level = 0; level < autoencmsg.length; level++) {
                  const encode = autoencmsg[level];
                  if (encode == undefined)
                      continue;
                  encode.image = new this.Matrix(encode.type).createBestImage(level, encode.data);
                  encode.gif = new GenQRCodeGIF(encode.image.matrix, scale);
                  encode.base64gif = GenQRCodeBase64.encode(encode.gif.binary);
              }
              this.autoEncodeMessage = autoencmsg;
              return autoencmsg;
          }
      }

      /* **************************************** */
      /*
       * QR 型に対する各種情報
       */

      class GenQRCodeType {

          /* 大きさの一覧 */
          static SizeListMicro  = [...Array(4)].map((_, i) => (11 + (i << 1)));
          static SizeListNormal = [...Array(40)].map((_, i) => (21 + (i << 2)));
          static SizeListAll = (GenQRCodeType.SizeListMicro.concat(GenQRCodeType.SizeListNormal));

          /* 型から大きさへの変換表  */
          static TypeSizeMap/*[micro]*/ = {
              true : [...Array( 4+1)].map((_, i) => (i ? ( 9 + (i << 1)) : undefined)),
              false: [...Array(40+1)].map((_, i) => (i ? (17 + (i << 2)) : undefined)),
          }

          /* 大きさから型への変換表  */
          static SizeTypeMap = function() {
              const r = new Map();
              for (let size of GenQRCodeType.SizeListAll) {
                  const micro = (size < 21);
                  const type = ((micro) ? ((size - 9) >> 1) : ((size - 17) >> 2));
                  r.set(size, { type: type, micro: micro });
              }
              return r;
          }();

          /* 総ブロック数算出用 */
          static BlockTable = [
              [[50,   450,  3522], [  1,   4,  84,  80,          64,   0,   5,  80,   5,  80], []],
              [[100,  919,  2076], [ 65,  88, 129,  22, 148,  66,  84,  81,   5,  85], []],
              [[135, 1353,  1712], [ 17, 102,  70, 198,          53,   2,  28,  85,  89, 170], [14]],
              [[158, 1785, -2009], [214,  86, 118,  13, 137,  28,  85, 149,  90, 238], [13, 15, 19, 22]],
          ]

          // 誤り訂正レベル.
          static CORRECT_NONE = 0;
          static CORRECT_L = 1;
          static CORRECT_M = 2;
          static CORRECT_Q = 3;
          static CORRECT_H = 4;
          static CORRECT_SIZE = 5;

          /* 誤り訂正コード数算出用 */
          static CorrectTable = [
              [205, [100, 107, 169, 248, 195], [1, 2]],
              [382, [  1, 175, 243, 255, 255], [20]],
              [565, [ 96, 239, 255, 255, 255], [1, 2, 3, 4]],
              [672, [ 80, 253,  71, 253, 253], []],
          ]

          /* BCH 符号生成 */
          static bchCoding(a, b, n) {
              const s = (n << 1);
              const m = (1 << s);
              let v = (a << n);
              for (let i = 0; i < n; i++) {
                  v <<= 1;
                  if ((v & m))
                      v ^= b;
              }
              return ((a << s) | v);
          }

          /* 型番用 BCH 符号生成 */
          static versionBCH(a) {
              return GenQRCodeType.bchCoding(a, 0x1f25, 6);
          }

          /* 形式用 BCH 符号生成 */
          static formatBCH(a, micro) {
              const b = (micro ? 0x4445 : 0x5412);
              return GenQRCodeType.bchCoding(a, 0x537, 5) ^ b;
          }

          /* 誤り訂正レベルとマスクの形式情報 */
          static FormatBCH = [...Array(4)].map((_, level) =>
              [...Array(8)].map((_, mask) => GenQRCodeType.formatBCH(((level ^ 1) << 3) | mask), false));

          /* 符号化表 */
          static EncodeTable = [...Array(7)].map(function(_, mode) {
              const U = undefined;
              const micro = (mode < 4);
              const mode_bits  = [0,1,2,3, 4, 4, 4][mode];
              const num_bits   = [3,4,5,6,10,12,14][mode];
              const alnum_bits = [U,3,4,5, 9,11,13][mode];
              const byte_bits  = [U,U,4,5, 8,16,16][mode];
              const kanji_bits = [U,U,3,4, 8,10,12][mode];
              const term_bits  = [3,5,7,9, 4, 4, 4][mode];
              const type_min   = [1,2,3,4, 1,10,27][mode];
              const type_max   = [1,2,3,4, 9,26,40][mode];
              const size_min   = [11,13,15,17, 21, 57,125][mode];
              const size_max   = [11,13,15,17, 53,121,177][mode];
              const lmax = ((b) => (b != U) ? ((1 << b) - 1) : U);
              return {
                  mode: mode,
                  micro: micro,
                  type_min: type_min,
                  type_max: type_max,
                  size_min: size_min,
                  size_max: size_max,

                  mode_bits : mode_bits,
                  num_bits  : num_bits,
                  alnum_bits: alnum_bits,
                  byte_bits : byte_bits,
                  kanji_bits: kanji_bits,
                  term_bits : term_bits,

                  num_max  : lmax(num_bits),
                  alnum_max: lmax(alnum_bits),
                  byte_max : lmax(byte_bits),
                  kanji_max: lmax(kanji_bits),

                  num_code   : (!micro ? 1 : ((mode >= 1) ? 0 : U)), 
                  alnum_code : (!micro ? 2 : ((mode >= 1) ? 1 : U)),
                  byte_code  : (!micro ? 4 : ((mode >= 2) ? 2 : U)),
                  kanji_code : (!micro ? 8 : ((mode >= 2) ? 3 : U)),
                  eci_code   : (!micro ? 7 : U),
                  append_code: (!micro ? 3 : U),
                  fnc11_code : (!micro ? 5 : U),
                  fnc12_code : (!micro ? 9 : U),
              }
          });

          // コンストラクタ(直接使用しない)
          //   fromSize または fromType を使用すること
          constructor(size) {
              const S = GenQRCodeType;
              this.S = S;

              const st = S.SizeTypeMap.get(size);
              if (st == undefined)
                  return undefined;

              const type = st.type;
              const micro = st.micro;

              this.name = ((micro ? 'M' : '') + type);
              this.size = size;
              this.type = type;
              this.micro = micro;
              this.versionBCH = ((type >= 7) ? S.versionBCH(type) : undefined);
              {
                  const qmods = (size * size);
                  let fmods, tmods;
                  if (micro) {
                      fmods = 64 + ((size - 8) << 1);
                      tmods = 15;
                  } else {
                      const nalign = (size < 25) ? 0 : Math.trunc((size + 40) / 28);
                      const amods = (nalign < 2) ? 0 : ((nalign * nalign - 3) * 25);
                      const cmods = (nalign < 3) ? 0 : ((nalign - 2) * 10);
                      fmods = 192 + ((size - 16) * 2) + amods - cmods;
                      tmods = 31 + ((size < 45) ? 0 : 36);
                  }
                  const dmods = qmods - fmods - tmods;
                  const codes = (dmods + (micro ? 7 : 0)) >> 3;
                  const rmods = micro ? 0 : (dmods & 7);

                  this.modules = { type: tmods, func: fmods, data: dmods, remainder: rmods };
                  this.codeWords = codes;
              }
              this.halfword = ((size == 11) || (size == 15));

              const itype = type - 1;
              const codes = this.codeWords;
              this.correct = [];
              if (size != 11)
                  this.correct.push(undefined);
              if (!micro) {
                  for (let level = 0; level < 4; level++) {
                      const btable = S.BlockTable[level];
                      const curv = btable[0];
                      const total = (((curv[0] * type * type + curv[1] * type + curv[2]) >> 12)
                                     + ((btable[1][itype >> 2] >> ((itype & 3) << 1)) & 3)
                                     + ((btable[2].indexOf(type) < 0) ? 0 : 4));

                      const count2 = codes % total;
                      const size1 = ((codes - count2) / total);
                      const count1 = total - count2;
                      const size2 = size1 + 1;

                      const ctable = S.CorrectTable[level];
                      const correct = (((ctable[0] * size1) >> 10)
                                       + ((ctable[1][itype >> 3] >> (itype & 7)) & 1)
                                       + ((ctable[2].indexOf(type) < 0) ? 0 :
                                          ((level != 2) ? 2 : ((type != 2) ? -1 : -2))));

                      const data1 = size1 - correct;
                      let words = data1 * count1;
                      let bdata = [{ size: size1, count: count1, data: data1, correct: correct }];
                      if (count2) {
                          const data2 = size2 - correct;
                          words += data2 * count2;
                          bdata.push({ size: size2, count: count2, data: data2, correct: correct });
                      }

                      this.correct.push({
                          block: bdata,
                          data: words,
                          data_bits: (words << 3),
                          correct: (codes - words),
                          format: S.FormatBCH[level],
                      });
                  }
                  this.encodeIndex = (((type >= 10) ? 1 : 0) +
                                      ((type >= 27) ? 1 : 0) + 4);
              } else {
                  const crdata = [[2],[5,5],[6,8],[8,10,14]][itype];
                  const size = [5,10,17,24][itype];
                  const symbol = [0,1,3,5][itype];
                  const last_remain = (this.halfword ? 4 : 0);

                  for (let level = 0; level < crdata.length; level++) {
                      const csize = crdata[level];
                      const dsize = codes - csize;
                      const bdata = [{ size: size, count: 1, data: dsize, correct: csize }];
                      this.correct.push({
                          block: bdata,
                          data: dsize,
                          data_bits: ((dsize << 3) - last_remain),
                          correct: csize,
                          format: [...Array(4)].map((_, mask) =>
                              GenQRCodeType.formatBCH((((level + symbol) << 2) | mask), true)),
                      });
                  }
                  this.encodeIndex = itype;
              }
              this.encode = S.EncodeTable[this.encodeIndex];
          }

          /* 大きさと GenQRCodeType の対応表 */
          static SizeMap = function() {
              const r = new Map();
              for (let size of GenQRCodeType.SizeListAll)
                  r.set(size, new GenQRCodeType(size));
              return r;
          }();

          /* 大きさから GenQRCodeType を得る */
          static fromSize(size) {
              return GenQRCodeType.SizeMap.get(size);
          }

          /* 型から GenQRCodeType を得る */
          static fromType(type, micro=false) {
              const S = GenQRCodeType;
              return S.fromSize(S.TypeSizeMap[micro][type]);
          }

          /*
           * メッセージの符号化処理
           */

          /* 文字列(UCS2)から UCS2 配列へ変換 */
          static toUcs2Array(msg) {
              return [...Array(msg.length)].map((_, i) => msg.charCodeAt(i));
          }

          /* 文字列(UCS2)から UCS4 配列へ変換 */
          static toUcs4Array(ucs2) {
              const slen = ucs2.length;
              const ucs4 = new Array();
              for (let i = 0; i < slen; i++) {
                  const c = ucs2.codePointAt(i);
                  ucs4.push(c);
                  if (c >= 0x10000)
                      i++;
              }
              return ucs4;
          }

          /* 英数の変換表 */
          static AlnumMap = {
              48: 0, 49: 1, 50: 2, 51: 3, 52: 4, 53: 5, 54: 6, 55: 7, 56: 8, 57: 9,
              65:10, 66:11, 67:12, 68:13, 69:14, 70:15, 71:16, 72:17, 73:18, 74:19,
              75:20, 76:21, 77:22, 78:23, 79:24, 80:25, 81:26, 82:27, 83:28, 84:29,
              85:30, 86:31, 87:32, 88:33, 89:34, 90:35, 32:36, 36:37, 37:38, 42:39,
              43:40, 45:41, 46:42, 47:43, 58:44,
          }

          /* 文字のフラグ */
          static CHAR_NUM    = 0x001;  /* 数値 */
          static CHAR_ALNUM  = 0x002;  /* 英数 */
          static CHAR_ASCII  = 0x004;  /* 7ビット文字 */
          static CHAR_BYTE   = 0x008;  /* 8ビット バイト */
          static CHAR_KANJI  = 0x010;  /* 漢字 */
          static CHAR_UTF8   = 0x020;  /* UTF-8 */
          static CHAR_CP932  = 0x040;  /* CP932 */
          static CHAR_CP932L = 0x080;  /* CP932(1byte) */
          static CHAR_CP932H = 0x100;  /* CP932(2byte) */

          /* ECI の文字セット */
          static ECI_8859 = 3;   // ISO-8859-1
          static ECI_SJIS = 20;  // Shift-JIS
          static ECI_UTF8 = 26;  // UTF-8

          /* 文字情報の生成 */
          static makeCharInfo(c, index) {
              const S = GenQRCodeType;
              const CP932 = GenQRCodeCP932;

              let eci = -1;
              let flag = 0;
              let alnum = S.AlnumMap[c];
              const cp932 = CP932.getCodeEx(c);
              const bit8 = [];
              const utf8 = [];

              if (c < 0x80) {
                  flag |= S.CHAR_ASCII | S.CHAR_BYTE | S.CHAR_CP932 | S.CHAR_UTF8;
                  bit8.push(c);
                  utf8.push(c);
              } else if (c < 0x800) {
                  utf8.push(0xc0 | (c >> 6));
                  utf8.push(0x80 | (c & 0x3f));
              } else if (c < 0x10000) {
                  utf8.push(0xe0 | (c >> 12));
                  utf8.push(0x80 | ((c >> 6) & 0x3f));
                  utf8.push(0x80 | (c & 0x3f));
              } else {
                  utf8.push(0xf0 | (c >> 18));
                  utf8.push(0x80 | ((c >> 12) & 0x3f));
                  utf8.push(0x80 | ((c >> 6) & 0x3f));
                  utf8.push(0x80 | (c & 0x3f));
              }

              if (alnum != undefined) {
                  flag |= S.CHAR_ALNUM | S.CHAR_BYTE | S.CHAR_CP932 | S.CHAR_UTF8;
                  if (alnum < 10)
                      flag |= S.CHAR_NUM;
              } else
                  alnum = -1;
              if (cp932 != undefined) {
                  flag |= S.CHAR_CP932 | S.CHAR_UTF8;
                  const d = cp932.cp932;
                  if (cp932.mode == CP932.MODE_KANA) {
                      eci = S.ECI_SJIS;
                      flag |= S.CHAR_CP932L;
                      bit8.push(d);
                  } else {
                      if (cp932.mode == CP932.MODE_KANJI) {
                          flag |= S.CHAR_KANJI;
                      } else {
                          eci = S.ECI_SJIS;
                          flag |= S.CHAR_CP932H;
                      }
                      bit8.push(d >> 8);
                      bit8.push(d & 0xff);
                  }
              }
              if (!flag) {
                  if (c < 0x100)
                      eci = S.ECI_8859;
                  else
                      eci = S.ECI_UTF8;
                  flag |= S.CHAR_UTF8;
              }

              return {
                  index: index,
                  prev: index - 1,
                  next: index + 1,
                  count: 1,

                  ucs: c,
                  eci: eci,
                  flag: flag,
                  alnum: alnum,
                  cp932: cp932,
                  bit8: bit8,
                  utf8: utf8,
              };
          }

          /* 文字列の文字単位での情報を生成 */
          static makeCharInfoList(msg, ucs4=false) {
              const S = GenQRCodeType;
              const ucs = ucs4 ? S.toUcs4Array(msg) : S.toUcs2Array(msg);
              return [...Array(ucs.length)].map((_, i) => S.makeCharInfo(ucs[i], i));
          }

          // メッセージの符号化.
          encodeMessage(message, jis=false, ucs4=false) {
              const debug = false;

              const S = GenQRCodeType;
              const charlist = S.makeCharInfoList(message, ucs4);
              const msglen = charlist.length;

              const output = new GenQRCodeBitStream();
              if (!msglen) return output;

              const encmode = this.encode;
              const bs_mode = encmode.mode_bits;

              const bs_num = encmode.num_bits;
              const bs_alnum = encmode.alnum_bits;
              const bs_byte = encmode.byte_bits;
              const bs_kanji = encmode.kanji_bits;

              const bs_m_num = bs_mode + bs_num;
              const bs_m_alnum = bs_mode + bs_alnum;
              const bs_m_byte = bs_mode + bs_byte;
              const bs_m_kanji = bs_mode + bs_kanji;

              const start_eci = (jis ? S.ECI_SJIS : S.ECI_8859);
              let char_flag = 0;
              {
                  let prev_flag = 0;
                  let last_pos = -1;
                  for (let i = 0; i < msglen; i++) {
                      const c = charlist[i];
                      c.next = i + 1;
                      c.count = 1;

                      const curr_flag = c.flag;
                      const flip_flag = prev_flag ^ curr_flag;

                      if (c.alnum >= 0) {
                          if (c.alnum < 10)
                              char_flag |= S.CHAR_NUM;
                          else
                              char_flag |= S.CHAR_ALNUM;
                      } else {
                          char_flag |= S.CHAR_BYTE;
                      }

                      prev_flag = curr_flag;
                      if (!flip_flag)
                          continue;
                      if (last_pos >= 0) {
                          const lc = charlist[last_pos];
                          lc.next = i;
                          lc.count = i - last_pos;
                          c.prev = last_pos;
                      }
                      last_pos = i;
                  }
                  if (last_pos >= 0) {
                      const lc = charlist[last_pos];
                      const count = msglen - last_pos;
                      lc.next = msglen;
                      lc.count = msglen - last_pos;
                  }
              }

              if (encmode.micro &&
                  (((bs_alnum == undefined) && (char_flag & S.CHAR_ALNUM)) ||
                   ((bs_byte  == undefined) && (char_flag & S.CHAR_BYTE))))
                  return undefined;

              const fscanner = function(callback) {
                  let index = 0;
                  while ((0 <= index) && (index < msglen)) {
                      const curr = charlist[index];
                      const prev = ((curr.prev >= 0) ? charlist[curr.prev] : undefined);
                      const next = ((curr.next < msglen) ? charlist[curr.next] : undefined);
                      index = callback(prev, curr, next);
                  }
              };

              const fnum_bits = function(count) {
                  const remain = (count % 3);
                  const block = (count - remain) / 3;
                  const data_bits = (block * 10) + ((remain * 3) + (remain ? 1 : 0));
                  return (bs_m_num + data_bits);
              };
              const max_num_bits = fnum_bits(encmode.num_max);

              const falnum_bits = function(count) {
                  const remain = count & 1;
                  const block = (count - remain) >> 1;
                  const data_bits = (block * 11) + (remain * 6);
                  return (bs_m_alnum + data_bits);
              };
              const max_alnum_bits = fnum_bits(encmode.alnum_max);

              const fbyte_bits = ((count) => bs_m_byte + (count * 8));
              const max_byte_bits = fbyte_bits(encmode.byte_max);

              const fkanji_bits = ((count) => bs_m_kanji + (count * 13));
              const max_kanji_bits = fbyte_bits(encmode.kanji_max);

              const fsegment_bits = function(count, segsize, segbits, fbits) {
                  const remain = count % segsize;
                  const segment = (count - remain) / segsize;
                  return (segment * segbits + (remain ? fbits(remain) : 0));
              };
              const fsegment_bits_sc = ((start, end, segsize, segbits, fbits) => fsegment_bits(end - start, segsize, segbits, fbits));
              const fsegment_bits_mc = ((start, end, segsize, segbits, fbits, fscan) => fsegment_bits(fscan(start, end), segsize, segbits, fbits));

              const fscan_byte = ((start, end) => charlist.slice(start, end).reduce(((p, c) => p + c.bit8.length), 0));
              const fscan_utf8 = ((start, end) => charlist.slice(start, end).reduce(((p, c) => p + c.utf8.length), 0));

              const fseg_num_bits   = ((start, end) => fsegment_bits_sc(start, end, encmode.num_max, max_num_bits, fnum_bits));
              const fseg_alnum_bits = ((start, end) => fsegment_bits_sc(start, end, encmode.alnum_max, max_alnum_bits, falnum_bits));
              const fseg_kanji_bits = ((start, end) => fsegment_bits_sc(start, end, encmode.kanji_max, max_kanji_bits, fkanji_bits));
              const fseg_byte_bits  = ((start, end) => fsegment_bits_mc(start, end, encmode.byte_max, max_byte_bits, fbyte_bits, fscan_byte));
              const fseg_utf8_bits  = ((start, end) => fsegment_bits_mc(start, end, encmode.byte_max, max_byte_bits, fbyte_bits, fscan_utf8));

              const fseg_auto_bits = ((flag, start, end) =>
                  ((flag & S.CHAR_NUM) ? fseg_num_bits(start, end)
                   : (flag & S.CHAR_ALNUM) ? fseg_alnum_bits(start, end)
                   : (flag & S.CHAR_KANJI) ? fseg_kanji_bits(start, end)
                   : (flag & (S.CHAR_BYTE | S.CHAR_CP932)) ? fseg_byte_bits(start, end)
                   : (flag & S.CHAR_UTF8) ? fseg_utf8_bits(start, end) : 0x10000));

              const feci_update2 = ((a, b) => ((a == b) ? a :
                                               (a == -1) ? b :
                                               (b == -1) ? a :
                                               (a == S.ECI_UTF8) ? a :
                                               (b == S.ECI_UTF8) ? b : a));
              const feci_update3 = ((a, b, c) => feci_update2(feci_update2(a, b), c));

              const fmerge_check = function(curr, other, omask) {
                  if (other == undefined) return false;
                  if (!(other.flag & omask)) return false;
                  if (curr.eci == other.eci) return true;
                  if ((curr.eci == -1) || (other.eci == -1)) return true;
                  if (((curr.eci == S.ECI_8859) || (curr.eci == S.ECI_SJIS)) && (other.eci == S.ECI_UTF8)) return true;
                  if ((curr.eci == S.ECI_UTF8) && ((other.eci == S.ECI_8859) || (other.eci == S.ECI_SJIS))) return true;
                  return false;
              };

              let merged = false;
              const fmerger = function(cmask, omask) {
                  fscanner(function(prev, curr, next) {
                      if (!(curr.flag & (cmask | omask)))
                          return curr.next;

                      const pmerge = fmerge_check(curr, prev, omask);
                      const nmerge = fmerge_check(curr, next, omask);
                      const pbits = (pmerge) ? fseg_auto_bits(prev.flag, prev.index, prev.next) : 0;
                      const cbits = fseg_auto_bits(curr.flag, curr.index, curr.next);
                      const nbits = (nmerge) ? fseg_auto_bits(next.flag, next.index, next.next) : 0;

                      if (pmerge && nmerge && fmerge_check(prev, next, omask)) {
                          const slen = pbits + cbits + nbits;
                          const mlen = fseg_auto_bits(omask, prev.index, next.next);
                          if (slen > mlen) {
                              prev.flag &= (curr.flag & next.flag);
                              prev.eci = feci_update3(prev.eci, curr.eci, next.eci);
                              prev.next = next.next;
                              prev.count = (prev.next - prev.index);
                              if (prev.next < msglen)
                                  charlist[prev.next].prev = prev.index;
                              merged = true;
                              return prev.index;
                          }
                      }
                      if (pmerge) {
                          const slen = pbits + cbits;
                          const mlen = fseg_auto_bits(omask, prev.index, curr.next);
                          if (slen <= mlen) return curr.next;

                          prev.flag &= curr.flag;
                          prev.eci = feci_update2(prev.eci, curr.eci);
                          prev.next = curr.next;
                          prev.count = (prev.next - prev.index);
                          if (next != undefined)
                              next.prev = prev.index;
                          merged = true;
                          return prev.index;
                      }
                      if (nmerge) {
                          const slen = cbits + nbits;
                          const mlen = fseg_auto_bits(omask, curr.index, next.next);
                          if (slen <= mlen) return curr.next;

                          curr.flag &= next.flag;
                          curr.eci = feci_update2(curr.eci, next.eci);
                          curr.next = next.next;
                          curr.count = (curr.next - curr.index);
                          if (curr.next < msglen)
                              charlist[curr.next].prev = curr.index;
                          merged = true;
                          return curr.index;
                      }
                      return curr.next;
                  });
              };

              do {
                  merged = false;
                  fmerger(S.CHAR_NUM, S.CHAR_ALNUM);
                  fmerger(S.CHAR_NUM, S.CHAR_BYTE);
                  fmerger(S.CHAR_NUM, S.CHAR_CP932);
                  fmerger(S.CHAR_NUM, S.CHAR_UTF8);
                  fmerger(S.CHAR_ALNUM, S.CHAR_BYTE);
                  fmerger(S.CHAR_ALNUM, S.CHAR_CP932);
                  fmerger(S.CHAR_ALNUM, S.CHAR_UTF8);
                  fmerger(S.CHAR_KANJI, S.CHAR_CP932);
                  fmerger(S.CHAR_KANJI, S.CHAR_UTF8);
                  fmerger(S.CHAR_ASCII, S.CHAR_BYTE);
                  fmerger(S.CHAR_BYTE, S.CHAR_CP932);
                  fmerger(S.CHAR_CP932, S.CHAR_UTF8);
              } while (merged);

              const fout_num = function(span) {
                  let index = span.index;
                  let count = span.count;
                  while (count > 0) {
                      let seglen = count;
                      if (seglen >= encmode.num_max)
                          seglen = encmode.num_max;
                      count -= seglen;

                      output.write(encmode.num_code, bs_mode);
                      output.write(seglen, bs_num);
                      while (seglen >= 3) {
                          const c1 = charlist[index++].alnum;
                          const c2 = charlist[index++].alnum;
                          const c3 = charlist[index++].alnum;
                          output.write((c1 * 100 + c2 * 10 + c3), 10);
                          seglen -= 3;
                      }
                      if (seglen == 2) {
                          const c1 = charlist[index++].alnum;
                          const c2 = charlist[index++].alnum;
                          output.write((c1 * 10 + c2), 7);
                      } else if (seglen == 1)
                          output.write(charlist[index++].alnum, 4);
                  }
              };

              const fout_alnum = function(span) {
                  let index = span.index;
                  let count = span.count;
                  while (count > 0) {
                      let seglen = count;
                      if (seglen >= encmode.alnum_max)
                          seglen = encmode.alnum_max;
                      count -= seglen;

                      output.write(encmode.alnum_code, bs_mode);
                      output.write(seglen, bs_alnum);
                      while (seglen >= 2) {
                          const c1 = charlist[index++].alnum;
                          const c2 = charlist[index++].alnum;
                          output.write((c1 * 45 + c2), 11);
                          seglen -= 2;
                      }
                      if (seglen == 1)
                          output.write(charlist[index++].alnum, 6);
                  }
              };

              const fout_byte_data = function(byte_data) {
                  let index = 0;
                  let count = byte_data.length;
                  while (count > 0) {
                      let seglen = count;
                      if (seglen >= encmode.byte_max)
                          seglen = encmode.byte_max;
                      count -= seglen;

                      output.write(encmode.byte_code, bs_mode);
                      output.write(seglen, bs_byte);
                      while (seglen-- > 0)
                          output.write(byte_data[index++], 8);
                  }
              };
              const fout_byte = function(span) {
                  let sp = span.index;
                  let ep = sp + span.count;
                  const byte_data = [];
                  while (sp < ep)
                      for (let b of charlist[sp++].bit8)
                          byte_data.push(b);
                  fout_byte_data(byte_data);
              };
              const fout_utf8 = function(span) {
                  let sp = span.index;
                  let ep = sp + span.count;
                  const byte_data = [];
                  while (sp < ep)
                      for (let b of charlist[sp++].utf8)
                          byte_data.push(b);
                  fout_byte_data(byte_data);
              };

              const fout_kanji = function(span) {
                  let index = span.index;
                  let count = span.count;
                  while (count > 0) {
                      let seglen = count;
                      if (seglen >= encmode.kanji_max)
                          seglen = encmode.kanji_max;
                      count -= seglen;

                      output.write(encmode.kanji_code, bs_mode);
                      output.write(seglen, bs_kanji);
                      while (seglen-- > 0)
                          output.write(charlist[index++].cp932.kanji, 13);
                  }
              };

              const feci_neq = ((a, b) => (a >= 0) && (b >= 0) && (a != b));
              {
                  let curr_eci = start_eci;
                  fscanner(function(prev, curr, next) {
                      const flag = curr.flag;
                      curr.eci = -1;
                      if (!(flag & (S.CHAR_NUM | S.CHAR_ALNUM | S.CHAR_ASCII | S.CHAR_KANJI))) {
                          if ((flag & S.CHAR_CP932))
                              curr.eci = S.ECI_SJIS;
                          else if ((flag & S.CHAR_UTF8))
                              curr.eci = S.ECI_UTF8;
                      }
                      return curr.next;
                  });
              }
              {
                  let use_eci = false;
                  let curr_eci = start_eci;
                  fscanner(function(p_, curr, n_) {
                      const eci = curr.eci;
                      const next = curr.next;
                      if (feci_neq(curr_eci, eci)) {
                          curr_eci = eci;
                          output.write(encmode.eci_code, bs_mode);
                          if (eci < 0x80) {
                              output.write(eci, 8);
                          } else if (eci < 0x4000) {
                              output.write(((eci >> 8) | 0x80), 8);
                              output.write((eci & 0xff), 8);
                          } else {
                              output.write(((eci >> 16) | 0xc0), 8);
                              output.write(((eci >> 8) & 0xff), 8);
                              output.write((eci & 0xff), 8);
                          }
                          use_eci = true;
                      }
                      const flag = curr.flag;
                      if ((flag & S.CHAR_NUM)) { fout_num(curr); return next; }
                      if ((flag & S.CHAR_ALNUM)) { fout_alnum(curr); return next; }
                      if ((flag & S.CHAR_KANJI)) { fout_kanji(curr); return next; }
                      if ((curr_eci == S.ECI_UTF8) &&
                          ((flag & (S.CHAR_CP932 | S.CHAR_UTF8)))) {
                          fout_utf8(curr);
                      } else
                          fout_byte(curr);
                      return next;
                  });
                  if (use_eci && encmode.micro)
                      return undefined;
              }

              if (debug) console.log(jis, this.decodeMessage(output, jis));

              return output;
          }

          // 誤り訂正レベルに対するサイズの調査.
          checkCodingSize(level, data_bits) {
              const correct = this.correct[level];
              return ((correct == undefined) ? false :
                      (data_bits <= correct.data_bits));
          }

          /* 誤り訂正レベル毎にメッセージが入る大きさで符号化する */
          static autoEncodeMessage(message, option=undefined) {
              const S = GenQRCodeType;

              const jis = (((option != undefined) && (option.jis != undefined))
                           ? option.jis : false);
              const sizelist = (((option != undefined) && (option.size != undefined))
                                ? option.size : S.SizeListAll);

              const output = new Array(S.CORRECT_SIZE);
              let encid = -1;
              let coding = undefined;
              let find = -1;
              for (let size of sizelist) {
                  const qr = S.fromSize(size);
                  if (encid != qr.encodeIndex) {
                      encid = qr.encodeIndex;
                      coding = qr.encodeMessage(message, jis, true);
                  }
                  if (coding == undefined)
                      continue;

                  let coding_size = coding.bit_length;
                  const correct = qr.correct;
                  for (let level = 0; level < S.CORRECT_SIZE; level++) {
                      if (output[level] != undefined) continue;
                      if (qr.checkCodingSize(level, coding_size)) {
                          output[level] = { type: qr, level: level, data: coding };
                          find = level + 1;
                      }
                  }
                  if (find == S.CORRECT_SIZE)
                      break;
              }
              return output;
          }

          // 最終的なメッセージ コード語を生成する.
          createMessageCode(correct_level, qrcode) {
              const P = GenQRCodeRSGFB8Polynomial;
              const correct = this.correct[correct_level];

              const term_bits = this.encode.term_bits;
              let data_remain = correct.data_bits - qrcode.bit_length;
              if (data_remain < 0) return undefined;
              const term_length = ((data_remain >= term_bits) ? term_bits : data_remain);

              const newcode = new GenQRCodeBitStream(qrcode);
              newcode.write(0, term_length);
              data_remain -= term_length;
              let ncrem = (newcode.bit_length & 7);
              if (ncrem > 0) {
                  newcode.write(0, ncrem);
                  data_remain -= ncrem;
              }
              while (data_remain >= 16) {
                  newcode.write(0xec, 8);
                  newcode.write(0x11, 8);
                  data_remain -= 16;
              }
              if (data_remain >= 8) {
                  newcode.write(0xec, 8);
                  data_remain -= 8;
              }
              if (data_remain > 0) {
                  newcode.write(data_remain, 8);
                  data_remain = 0;
              }

              const msgblk = [];
              const crblk = [];
              let dpos = 0;
              let dvirtlen = 0;
              let cvirtlen = 0;
              for (let block of correct.block) {
                  let dsize = block.data;
                  let csize = block.correct;
                  if (dvirtlen < dsize) dvirtlen = dsize;
                  if (cvirtlen < csize) cvirtlen = csize;
                  const dadd = Array(csize).fill(0);
                  const pgen = P.fromGenerator(csize);
                  for (let bcnt = block.count; bcnt > 0; bcnt--) {
                      let dend = dpos + dsize;
                      const dblk = newcode.slice(dpos, dend);
                      msgblk.push(dblk);
                      const rsc = P.fromData(dblk.concat(dadd), true).mod(pgen).polynomial;
                      while (rsc.length < csize) rsc.push(0);
                      crblk.push([...Array(rsc.length)].map((_, i) => rsc[rsc.length - i - 1].element));
                      dpos = dend;
                  }
              }

              const r_data = [];
              for (let i = 0; i < dvirtlen; i++)
                  for (let d of msgblk)
                      if (i < d.length)
                          r_data.push(d[i]);

              const r_correct = [];
              for (let i = 0; i < cvirtlen; i++)
                  for (let c of crblk)
                      if (i < c.length)
                          r_correct.push(c[i]);

              let r_codeword;
              if (this.micro && ((this.type == 1) || (this.type == 3))) {
                  let lcw = r_data[r_data.length - 1];
                  r_codeword = r_data.slice(0, r_data.length - 1);
                  for (let d of r_correct) {
                      r_codeword.push(lcw | (d >> 4));
                      lcw = (d & 15) << 4;
                  }
                  r_codeword.push(lcw);
              } else
                  r_codeword = r_data.concat(r_correct);
              r_codeword.push(0);

              return { codeword: r_codeword, data: r_data, correct: r_correct };
          }

          // メッセージの復号(デバッグ用).
          decodeMessage(qrcode, jis=false) {
              const debug = false;

              const S = GenQRCodeType;
              const encmode = this.encode;

              const data = new GenQRCodeBitStream(qrcode);
              const ALNUM = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';
              const eci3dec = new TextDecoder('iso8859-1');
              const sjisdec = new TextDecoder('shift_jis');
              const utf8dec = new TextDecoder();

              if (debug) console.log('decodeMessage:' + jis);

              let eci = (jis ? S.ECI_SJIS : S.ECI_8859);
              let msg = '';
              for (;;) {
                  const mode = data.read(encmode.mode_bits);
                  if (debug) console.log('  mode: ' + mode);
                  switch (mode) {
                  case undefined:
                  case 0:
                      return msg;
                  case encmode.num_code:
                      {
                          let len = data.read(encmode.num_bits);
                          if (debug) console.log('  NUM[' + len + ']');
                          while (len >= 3) {
                              const d1 = data.read(10);
                              const c1 = d1 % 10;
                              const d2 = ((d1 - c1) / 10);
                              const c2 = d2 % 10;
                              const c3 = ((d2 - c2) / 10);
                              msg += c3;
                              msg += c2;
                              msg += c1;
                              len -= 3;
                          }
                          switch (len) {
                          case 2:
                              {
                                  const d1 = data.read(7);
                                  const c1 = d1 % 10;
                                  const c2 = ((d1 - c1) / 10);
                                  msg += c2;
                                  msg += c1;
                              }
                              break;
                          case 1:
                              msg += data.read(4);
                              break;
                          }
                      }
                      break;
                  case encmode.alnum_code:
                      {
                          let len = data.read(encmode.alnum_bits);
                          if (debug) console.log('  ALNUM[' + len + ']');
                          while (len >= 2) {
                              const d1 = data.read(11);
                              const c1 = d1 % 45;
                              const c2 = (d1 - c1) / 45;
                              msg += ALNUM[c2];
                              msg += ALNUM[c1];
                              len -= 2;
                          }
                          if (len == 1)
                              msg += ALNUM[data.read(6)];
                      }
                      break;
                  case encmode.kanji_code:
                      {
                          const len = data.read(encmode.kanji_bits);
                          let kanji = [];
                          while (kanji.length < (len << 1)) {
                              const d = data.read(13);
                              let l = (d % 192);
                              let h = (d - l) / 192;
                              kanji.push(h + ((h < 0x20) ? 0x81 : 0xc1));
                              kanji.push(l + 0x40);
                          }
                          if (debug) console.log('  KANJI[' + len + ']', kanji);
                          msg += sjisdec.decode(new Uint8Array(kanji));
                      }
                      break;
                  case encmode.byte_code:
                      {
                          const len = data.read(encmode.byte_bits);
                          const bytes = new Uint8Array([...Array(len)].map(() => data.read(8)));
                          if (debug) console.log('  BYTE[' + len + ']', bytes);
                          switch (eci) {
                          case S.ECI_8859: msg += eci3dec.decode(bytes); break;
                          case S.ECI_SJIS: msg += sjisdec.decode(bytes); break;
                          case S.ECI_UTF8: msg += utf8dec.decode(bytes); break;
                          default: return undefined; // 上記以外の文字セットは非対応.
                          }
                      }
                      break;
                  case encmode.eci_code:
                      {
                          const b1 = data.read(8);
                          if (b1 < 0x80) {
                              eci = b1;
                              if (debug) console.log('  ECI[' + eci + ']');
                              break;
                          }
                          const b2 = data.read(8);
                          if (b1 < 0xc0) {
                              eci = ((b1 & 0x3f) << 8) | b2;
                              if (debug) console.log('  ECI[' + eci + ']');
                              break;
                          }
                          const b3 = data.read(8);
                          eci = (((b1 & 0x1f) << 16) | (b2 << 8) | b3);
                          if (debug) console.log('  ECI[' + eci + ']');
                      }
                      break;
                  default:
                      return undefined;
                  }
              }
          }

          /* 文字のエスケープ */
          static escapeBackslash(message) { return message.replace('\\', '\\\\'); }
          static unescapeBackslash(message) { return message.replace('\\\\', '\\'); }
      }

      /* **************************************** */
      /*
       * 誤り訂正(リード・ソロモン符号)用係数 GF(2^8)
       */

      class GenQRCodeRSGFB8 {

          /* a^n の指数 n から 8 ビット列への変換表 */
          static ELEMENT_TABLE = function() {
              let a = 1;
              return [...Array(255)].map((_, i) =>
                  !i ? a : (((a *= 2) < 256) ? a : (a ^= 285)));
          }();

          /* 8 ビット列から a^n の指数 n への変換表 */
          static EXPONENT_TABLE = function() {
              const e = GenQRCodeRSGFB8.ELEMENT_TABLE;
              return [...Array(256)].map((_, i) =>
                  !i ? undefined : e.indexOf(i));
          }();

          /* (element=α^n) のオブジェクトを得る */
          static fromElement(element) {
              return new GenQRCodeRSGFB8(element, GenQRCodeRSGFB8.EXPONENT_TABLE[element]);
          }

          /* α^exponent のオブジェクトを得る */
          static fromExponent(exponent) {
              return new GenQRCodeRSGFB8(GenQRCodeRSGFB8.ELEMENT_TABLE[exponent], exponent);
          }

          // コンストラクタ：直接呼ばない.
          constructor(element, exponent) {
              this.element = element;
              this.exponent = exponent;
          }

          // 値が 0 か?
          isZero() { return (!this.element); }

          // GF(2) による加算.
          addElement(rhs) { return GenQRCodeRSGFB8.fromElement(this.element ^ rhs.element); }

          // 指数を増やした値を得る.
          addExponent(value) {
              return (this.element
                      ? GenQRCodeRSGFB8.fromExponent((this.exponent + value) % 255)
                      : GenQRCodeRSGFB8.fromElement(0));
          }
      }

      /*
       * 誤り訂正(リード・ソロモン符号)用多項式計算
       */

      class GenQRCodeRSGFB8Polynomial {

          /*
           * 生成多項式の表
           *   P[n](x) = (x - a^0)(x - a^1)...(x - a^(n-1))
           */
          static GENERATOR_POLYNOMIAL = function() {
              const S = GenQRCodeRSGFB8;
              const p = S.ELEMENT_TABLE;
              const q = S.EXPONENT_TABLE;
              const z = S.fromExponent(0);
              let g = [z, z];
              return [...Array(69)].map((_, i) =>
                  ((i == 0) ? [] :
                   ((i == 1) ? g :
                    (g = [...Array(i+1)].map((_, j) =>
                        ((j == 0) ? g[0].addExponent(i - 1) :
                         ((j == i) ? z : g[j - 1].addElement(g[j].addExponent(i - 1)))))))));
          }();

          /* 生成多項式のオブジェクト（除数）を得る */
          static fromGenerator(level) {
              const S = GenQRCodeRSGFB8Polynomial;
              return new S(S.GENERATOR_POLYNOMIAL[level]);
          }

          /* (0〜255整数)配列から多項式のオブジェクト（被除数）を得る */
          static fromData(data, reverse=false) {
              const dlen = data.length - 1;
              return new GenQRCodeRSGFB8Polynomial(
                  [...Array(data.length)].map((_, i) =>
                      GenQRCodeRSGFB8.fromElement(data[reverse ? (dlen - i) : i])));
          }

          // コンストラクタ：直接呼ばない.
          constructor(polynomial) {
              this.polynomial = polynomial;
          }

          // 有効な次数を得る.
          validLength() {
              const p = this.polynomial;
              for (let n = p.length; n > 0; n--)
                  if (!p[n - 1].isZero())
                      return n;
              return 0;
          }

          // 剰余を算出.
          mod(rhs) {
              const rplen = rhs.validLength();
              if (!rplen) return undefined;

              const org = this.polynomial;
              let lplen = this.validLength();
              const lp = [...Array(lplen)].map((_, i) => org[i]);

              const rp = rhs.polynomial;
              const rptop = rp[rplen - 1];
              const rpexp = 255 - rptop.exponent;

              for (let roffs = lplen - rplen; roffs >= 0; roffs--, lplen--) {
                  const lptop = lp[lplen - 1];
                  if (lptop.isZero()) continue;
                  const lpexp = lptop.exponent;
                  const mexp = (lpexp + rpexp) % 255;
                  for (let p = roffs, q = 0; p < lplen; p++, q++)
                      lp[p] = lp[p].addElement(rp[q].addExponent(mexp));
              }
              return new GenQRCodeRSGFB8Polynomial(lp.slice(0, lplen));
          }
      }

      /* **************************************** */
      /*
       * ビット列のデータをバイト単位で保持する
       */

      class GenQRCodeBitStream {

          // コンストラクタ.
          constructor(src=undefined) {
              const self = this;
              if (src != undefined) {
                  if (src.data != undefined) {
                      this.data = [].concat(src.data);
                      this.rpos = src.rpos;
                      this.wpos = src.wpos;
                  } else {
                      this.data = src;
                      this.rpos = 0;
                      this.wpos = (src.length << 3);
                  }
              } else {
                  this.data = [];
                  this.rpos = 0;
                  this.wpos = 0;
              }
              return new Proxy(this, {
                  get: ((target, prop) =>
                      (prop in target) ? target[prop] : self.data[prop]
                  ),
              });
          }

          // Array.slice
          slice(start, end) {
              return this.data.slice(start, end);
          }

          // オブジェクトの複製.
          clone() { return GenQRCodeBitStream(this); }

          // ビット単位での読み出し.
          read(bits) {
              let pos = this.rpos;
              let rem = this.wpos - pos;
              if (rem > bits) rem = bits;
              this.rpos = pos + rem;

              const data = this.data;
              let value = 0;
              while (rem > 0) {
                  let rbits = (8 - (pos & 7));
                  let step = ((rbits < rem) ? rbits : rem);
                  value = ((value << step) |
                           ((data[pos >> 3] >> (rbits - step)) &
                            ((1 << step) - 1)));
                  pos += step;
                  rem -= step;
              }
              return value;
          }

          // ビット単位でのデータ追記.
          // （ビッグ エンディアン）
          write(data, bits) {
              if (bits <= 0)
                  return;

              let pos = this.wpos;
              let rbits = (pos & 7);
              const buffer = this.data;
              this.wpos = pos + bits;

              if (rbits) {
                  rbits = 8 - rbits;

                  const last = buffer.length - 1;
                  const mask = (1 << rbits) - 1;
                  if (rbits >= bits) {
                      buffer[last] |= (data << (rbits - bits)) & mask;
                      return;
                  }
                  buffer[last] |= (data >> ((bits - rbits))) & mask;
                  bits -= rbits;
              }
              while (bits > 8) {
                  bits -= 8;
                  buffer.push((data >> bits) & 0xff);
              }
              buffer.push((data << (8 - bits)) & 0xff);
          }

          [Symbol.iterator]() { return this.data[Symbol.iterator](); }  // 反復子を得る
          get length() { return this.data.length; }  // バイト長を得る
          get bit_length() { return this.wpos; }      // ビット長を得る
      }

      /* **************************************** */
      /*
       * QR 画像用の N×N 配列
       *   右下が原点で、X が上で Y が左： ←(Y,X)↑
       *   JIS X 0510 の座標系とは異なる
       */

      class GenQRCodeMatrix {

          /* 位置検出パターン */
          static FinderPattern = [...Array(7)].map((_, i) => [...Array(7)].map(
              (_, j) => (Math.max(Math.abs(i - 3), Math.abs(j - 3)) == 2) ? 2 : 1));

          /* 位置合わせパターン */
          static AlignmentPattern = [...Array(5)].map((_, i) => [...Array(5)].map(
              (_, j) => (Math.max(Math.abs(i - 2), Math.abs(j - 2)) == 1) ? 2 : 1));

          /* タイミング パターン */
          static TimingPattern = [...Array(177)].map((_, i) => ((i & 1) + 1));

          // コンストラクタ.
          constructor(type) {
              const S = GenQRCodeMatrix;

              this.S = S;
              this.FinderPattern = S.FinderPattern;
              this.AlignmentPattern = S.AlignmentPattern;
              this.TimingPattern = S.TimingPattern;

              this.type = type;
              this.micro = type.micro;
              this.module_size = type.size;

              this.clearMatrix();
              this.setFunctionPattern();
          }

          // ゼロ クリア.
          clearMatrix() {
              const size = this.module_size;
              this.matrix = [...Array(size)].map(() => Array(size).fill(0));
          }

          // 複製する.
          clone(mask=3) {
              const robj = new GenQRCodeMatrix(this.type);
              const size = this.module_size;

              for (let y = 0; y < size; y++) {
                  const sl = this.matrix[y];
                  const dl = robj.matrix[y];
                  for (let x = 0; x < size; x++)
                      dl[x] = sl[x] & mask;
              }
              return robj;
          }

          // 指定座標の取得と設定.
          getValue(x, y) { return this.matrix[y][x]; }
          setValue(x, y, value) { this.matrix[y][x] = value; }

          // パターンの配置(汎用)
          setPattern(x, y, pattern) {
              const matrix = this.matrix;
              for (let span of pattern) {
                  const line = matrix[y];
                  matrix[y++] = line.slice(0, x).concat(
                      span,
                      line.slice(x + span.length)
                  );
              }
          }

          // X 軸方向への線の描画.
          setXLine(value, y, x1, x2) {
              if (x1 > x2)
                  [x1, x2] = [x2, x1];
              x2++;

              const matrix = this.matrix;
              const line = matrix[y];
              matrix[y] = line.slice(0, x1).concat(
                  Array(x2 - x1).fill(value),
                  line.slice(x2)
              );
          }

          // Y 軸方向への線の描画.
          setYLine(value, x, y1, y2) {
              if (y1 > y2)
                  [y1, y2] = [y2, y1];

              const matrix = this.matrix;
              for (let y = y1; y <= y2; y++)
                  matrix[y][x] = value;
          }

          // 位置検出パターンの配置.
          setFinder() {
              const pattern = this.FinderPattern;
              const z0 = this.module_size - 7;
              const z6 = z0 + 6;
              const za = z0 - 1;

              this.setPattern(z0, z0, pattern);
              this.setXLine(2, za, za, z6);
              this.setYLine(2, za, z0, z6);
              if (this.micro) return;

              this.setPattern(z0, 0, pattern);
              this.setXLine(2,  7, za, z6);
              this.setYLine(2, za,  0,  6);

              this.setPattern(0, z0, pattern);
              this.setXLine(2, za,  0,  7);
              this.setYLine(2,  7, z0, z6);
          }

          // 位置合わせパターンの配置.
          setAlignment() {
              const size = this.module_size;
              if (size < 25) return;

              const plast = size - 9;
              const steps = Math.trunc((size + 12) / 28);
              const ptmp = ((((size - 13) + (steps >> 1)) / steps) + 1) & ~1;
              const pstep = ptmp + (ptmp & 1);
              const pos = [...Array(steps)].map((_, i) => (i * pstep) + 4);
              pos.push(plast);

              const pattern = this.AlignmentPattern;
              const pcnt = pos.length;

              const qcnt = pcnt - 1;
              for (let x = 0; x < qcnt; x++)
                  this.setPattern(pos[x], 4, pattern);
              for (let y = 1; y < qcnt; y++) {
                  const ay = pos[y];
                  for (let x = 0; x < pcnt; x++)
                      this.setPattern(pos[x], ay, pattern);
              }
              for (let x = 1; x < qcnt; x++)
                  this.setPattern(pos[x], plast, pattern);
          }

          // タイミング パターンの配置.
          setTiming() {
              const pattern = this.TimingPattern;
              const matrix = this.matrix;
              const size = this.module_size;
              const last = size - 1;
              const term = size - 7;
              let x = term;
              let ys = 8;
              let ye = term;

              if (!this.micro) {
                  let line = matrix[ye];
                  matrix[ye] = line.slice(0, 8).concat(
                      pattern.slice(8, term),
                      line.slice(term)
                  );
              } else {
                  let line = matrix[last];
                  matrix[last] = pattern.slice(0, term).concat(
                      line.slice(term, size)
                  );
                  x = last;
                  ys = 0;
              }

              let value = 1;
              for (let y = ys; y < ye; y++) {
                  matrix[y][x] = value;
                  value = 3 - value;
              }
          }

          // 機能パターンと形式および型番情報の配置.
          setFunctionPattern() {
              this.setFinder();
              this.setTiming();
              this.setAlignment();
          }

          // 形式情報および型番情報を設定.
          setFormat(format=0, version=0) {
              const matrix = this.matrix;
              const size = this.module_size;
              const last = size - 1;
              const last1 = last - 1;
              const last6 = last - 6;
              const last8 = last - 8;

              if (this.micro) {
                  let bl = 0;
                  let bh = 14;
                  let x = last1;
                  let y = last8;
                  let line = matrix[y];
                  for (let i = 0; i < 8; i++) {
                      line[x]      = (2 - ((format >> bh--) & 1));
                      matrix[x][y] = (2 - ((format >> bl++) & 1));
                      x--;
                  }
                  return; /* ** */
              } else {
                  let bl = 0;
                  let bh = 14;
                  let x;// = 0;
                  let y = last8;
                  let line = matrix[y];
                  for (x = 0; x < 7; x++) {
                      line[x]      = (2 - ((format >> bh--) & 1));
                      matrix[x][y] = (2 - ((format >> bl++) & 1));
                  }
                  line[x] = 1;
                  matrix[x][y] = (2 - ((format >> bl++) & 1));
                  x = last8;
                  matrix[x][y] = (2 - ((format >> bh--) & 1));
                  x++;
                  line[x]      = (2 - ((format >> bh--) & 1));
                  matrix[x][y] = (2 - ((format >> bl++) & 1));
                  x++;
                  while (++x < size) {
                      line[x]      = (2 - ((format >> bh--) & 1));
                      matrix[x][y] = (2 - ((format >> bl++) & 1));
                  }
              }
              if (size >= 45) {
                  let x = last;
                  let y = 8;
                  let line3 = matrix[ 8];
                  let line2 = matrix[ 9];
                  let line1 = matrix[10];
                  for (let i = 0; i < 6; i++) {
                      let v1 = (2 - (version & 1)); version >>= 1;
                      let v2 = (2 - (version & 1)); version >>= 1;
                      let v3 = (2 - (version & 1)); version >>= 1;
                      line1[x] = v1;
                      line2[x] = v2;
                      line3[x] = v3;
                      matrix[x][y]     = v3;
                      matrix[x][y + 1] = v2;
                      matrix[x][y + 2] = v1;
                      x--;
                  }
              }
          }

          // コード語を配置したイメージを生成.
          createImage(codeword, pattern_id) {
              const S = this.S;
              const micro = this.micro;
              const matrix = this.matrix;
              const size = this.module_size;
              const last = size - 1;
              const skip = (micro ? -1 : size - 7);

              const pattern = S.maskPattern[micro][pattern_id];
              const mask_offset = (180 - size) % 12; // 12*15 = 177+3

              const image = this.clone(1);
              const imgmtx = image.matrix;
              const color = ((p, x, y) => (((codeword[p >> 3] >> (7 ^ (p & 7))) & 1)
                                           ^ pattern[(mask_offset + y) % 12][(mask_offset + x) % 12]));

              let cwp = 0;
              for (let y1 = 0; y1 < last; y1 += 2) {
                  {
                      const y2 = y1 + 1;
                      const srow1 = matrix[y1];
                      const srow2 = matrix[y2];
                      const drow1 = imgmtx[y1];
                      const drow2 = imgmtx[y2];

                      for (let x = 0; x < size; x++) {
                          if (!srow1[x]) drow1[x] = color(cwp++, x, y1);
                          if (!srow2[x]) drow2[x] = color(cwp++, x, y2);
                      }
                  }
                  y1 += 2;
                  if (y1 == skip)
                      y1++;
                  else if (y1 >= last)
                      break;
                  {
                      const y2 = y1 + 1;
                      const srow1 = matrix[y1];
                      const srow2 = matrix[y2];
                      const drow1 = imgmtx[y1];
                      const drow2 = imgmtx[y2];

                      for (let x = size - 1; x >= 0; x--) {
                          if (!srow1[x]) drow1[x] = color(cwp++, x, y1);
                          if (!srow2[x]) drow2[x] = color(cwp++, x, y2);
                      }
                  }
              }

              return image;
          }

          // 全マスク パターンのイメージを生成.
          createAllImage(correct_level, codedata) {
              const qrtype = this.type;
              const msgcode = qrtype.createMessageCode(correct_level, codedata);
              const codeword = msgcode.codeword;
              const correct = qrtype.correct[correct_level];
              const format = correct.format;
              const fmtlen = format.length;
              const versionBCH = qrtype.versionBCH;
              const image = [];
              for (let i = 0; i < format.length; i++) {
                  this.setFormat(format[i], versionBCH);
                  image.push(this.createImage(codeword, i));
              }
              return image;
          }

          /* マスク処理結果の評価値を得る */
          getPatternScore() {
              const qrtype = this.type;
              const size = this.module_size;
              const last = size - 1;

              if (qrtype.micro) {
                  let sum1 = 0;
                  let sum2 = 0;
                  for (let p = 0; p < last; p++) {
                      sum1 += this.getValue(p, 0);
                      sum2 += this.getValue(0, p);
                  }
                  if (sum1 > sum2)
                      [sum1, sum2] = [sum2, sum1];
                  return (sum1 * 16 + sum2);
              }

              const matrix = this.matrix;
              let score = 0;
              {
                  for (let y = 0; y < size; y++) {
                      let last = -1;
                      let count = 0;
                      for (let v of matrix[y]) {
                          if (v == last) {
                              count++;
                              continue;
                          }
                          if (count >= 5)
                              score += (count - 2);
                          last = v;
                          count = 0;
                      }
                      if (count >= 5)
                          score += (count - 2);
                  }
                  for (let x = 0; x < size; x++) {
                      let last = -1;
                      let count = 0;
                      for (let y = 0; y < size; y++) {
                          const v = matrix[y][x];
                          if (v == last) {
                              count++;
                              continue;
                          }
                          if (count >= 5)
                              score += (count - 2);
                          last = v;
                          count = 0;
                      }
                      if (count >= 5)
                          score += (count - 2);
                  }
              }
              {
                  for (let y = 0; y < last; y++) {
                      const line1 = matrix[y];
                      const line2 = matrix[y + 1];

                      for (let x = 0; x < last; x++) {
                          const v11 = line1[x];
                          const v12 = line1[x + 1];
                          const v21 = line2[x];
                          const v22 = line2[x + 1];

                          if ((v11 == v12) && (v11 == v21) && (v11 == v22))
                              score += 3;
                      }
                  }
              }
              {
                  const w = size - 11;

                  for (let y = 0; y < size; y++) {
                      const line = matrix[y];
                      for (let x = 0; x < w; x++) {
                          do {
                              if (line[x     ] != 1) break;
                              if (line[x +  1] != 0) break;
                              if (line[x +  2] != 1) break;
                              if (line[x +  3] != 1) break;
                              if (line[x +  4] != 1) break;
                              if (line[x +  5] != 0) break;
                              if (line[x +  6] != 1) break;
                              if (line[x +  7] != 0) break;
                              if (line[x +  8] != 0) break;
                              if (line[x +  9] != 0) break;
                              if (line[x + 10] != 0) break;
                              score += 40;
                          } while (false);
                          do {
                              if (line[x     ] != 0) break;
                              if (line[x +  1] != 0) break;
                              if (line[x +  2] != 0) break;
                              if (line[x +  3] != 0) break;
                              if (line[x +  4] != 1) break;
                              if (line[x +  5] != 0) break;
                              if (line[x +  6] != 1) break;
                              if (line[x +  7] != 1) break;
                              if (line[x +  8] != 1) break;
                              if (line[x +  9] != 0) break;
                              if (line[x + 10] != 1) break;
                              score += 40;
                          } while (false);
                      }
                  }

                  for (let x = 0; x < size; x++) {
                      for (let y = 0; y < w; y++) {
                          do {
                              if (matrix[y     ][x] != 1) break;
                              if (matrix[y +  1][x] != 0) break;
                              if (matrix[y +  2][x] != 1) break;
                              if (matrix[y +  3][x] != 1) break;
                              if (matrix[y +  4][x] != 1) break;
                              if (matrix[y +  5][x] != 0) break;
                              if (matrix[y +  6][x] != 1) break;
                              if (matrix[y +  7][x] != 0) break;
                              if (matrix[y +  8][x] != 0) break;
                              if (matrix[y +  9][x] != 0) break;
                              if (matrix[y + 10][x] != 0) break;
                              score += 40;
                          } while (false);
                          do {
                              if (matrix[y     ][x] != 0) break;
                              if (matrix[y +  1][x] != 0) break;
                              if (matrix[y +  2][x] != 0) break;
                              if (matrix[y +  3][x] != 0) break;
                              if (matrix[y +  4][x] != 1) break;
                              if (matrix[y +  5][x] != 0) break;
                              if (matrix[y +  6][x] != 1) break;
                              if (matrix[y +  7][x] != 1) break;
                              if (matrix[y +  8][x] != 1) break;
                              if (matrix[y +  9][x] != 0) break;
                              if (matrix[y + 10][x] != 1) break;
                              score += 40;
                          } while (false);
                      }
                  }
              }
              {
                  const dark = matrix.reduce(((yp, line) => yp + line.reduce(((xp, v) => xp + v), 0)), 0);
                  const rate = Math.trunc((dark * 100) / (size * size));
                  score += 10 * Math.trunc(Math.abs(rate - 50) / 5);
              }
              return score;
          }

          /* 最良イメージを得る */
          createBestImage(correct_level, codedata) {
              const images = this.createAllImage(correct_level, codedata);
              const scores = images.map(img => img.getPatternScore());
              return images[scores.indexOf(Math.min.apply(null, scores))];
          }

          /* マスク パターン */
          static makeMaskPattern = ((f) => [...Array(12)].map((_, j) => [...Array(12)].map((_, i) => f(11-i, 11-j))));
          static maskPattern0 = GenQRCodeMatrix.makeMaskPattern((i, j) => (!((i + j) & 1) ? 1 : 0));
          static maskPattern1 = GenQRCodeMatrix.makeMaskPattern((i, j) => (!(i & 1) ? 1 : 0));
          static maskPattern2 = GenQRCodeMatrix.makeMaskPattern((i, j) => (!(j % 3) ? 1 : 0));
          static maskPattern3 = GenQRCodeMatrix.makeMaskPattern((i, j) => (!((i + j) % 3) ? 1 : 0));
          static maskPattern4 = GenQRCodeMatrix.makeMaskPattern((i, j) => (!((Math.trunc(i / 2) + Math.trunc(j / 3)) & 1) ? 1 : 0));
          static maskPattern5 = GenQRCodeMatrix.makeMaskPattern((i, j) => (!((i * j) % 6) ? 1 : 0));
          static maskPattern6 = GenQRCodeMatrix.makeMaskPattern((i, j) => (!((((i * j) & 1) + ((i * j) % 3)) & 1) ? 1 : 0));
          static maskPattern7 = GenQRCodeMatrix.makeMaskPattern((i, j) => (!((((i + j) & 1) + ((i * j) % 3)) & 1) ? 1 : 0));
          static maskPattern/*[micro]*/= {
              true: [
                  GenQRCodeMatrix.maskPattern1,
                  GenQRCodeMatrix.maskPattern4,
                  GenQRCodeMatrix.maskPattern6,
                  GenQRCodeMatrix.maskPattern7,
              ],
              false: [
                  GenQRCodeMatrix.maskPattern0,
                  GenQRCodeMatrix.maskPattern1,
                  GenQRCodeMatrix.maskPattern2,
                  GenQRCodeMatrix.maskPattern3,
                  GenQRCodeMatrix.maskPattern4,
                  GenQRCodeMatrix.maskPattern5,
                  GenQRCodeMatrix.maskPattern6,
                  GenQRCodeMatrix.maskPattern7,
              ],
          }
      }

      /* **************************************** */
      /*
       * 正方二次元配列(N×N) から GIF バイナリ(0〜255整数)配列を生成
       *   入力値と色 = { 0:白, 1:黒, 2:灰, 3:透明 }
       *   QR コード用にクワイエットゾーンが追加される
       */

      class GenQRCodeGIF {

          // コンストラクタ.
          constructor(qrcode, scale=2) {
              const qrsize = qrcode.length;
              const padding = ((qrsize < 21) ? 2 : 4);

              const spadding = padding * scale;
              const swidth = (qrsize + padding * 2) * scale;
              const sheight = swidth;

              const x0data = Array(spadding).fill(0);
              const y0data = Array(swidth).fill(0);

              let data = [];
              for (let y = 0; y < spadding; y++)
                  data.push.apply(data, y0data);
              for (let x = qrsize - 1; x >= 0; x--) {
                  let line = x0data.concat([]);
                  for (let y = qrsize - 1; y >= 0; y--) {
                      const d = qrcode[y][x];
                      for (let ys = 0; ys < scale; ys++)
                          line.push(d);
                  }
                  line.push.apply(line, x0data);
                  for (let ys = 0; ys < scale; ys++)
                      data.push.apply(data, line);
              }
              for (let y = 0; y < spadding; y++)
                  data.push.apply(data, y0data);

              this.S = GenQRCodeGIF;
              this.width = swidth;
              this.height = sheight;
              this.source = data;

              this.binary = [
                  0x47, 0x49, 0x46, // Signature
                  0x38, 0x39, 0x61, // Version89a

                  // Logical Screen Descriptor
                  (swidth & 0xff), ((swidth >> 8) & 0xff),
                  (sheight & 0xff),((sheight >> 8) & 0xff),
                  0x91, 3, 49,

                  // Global Color Table
                  0xff, 0xff, 0xff,  // 白.
                  0x00, 0x00, 0x00,  // 黒.
                  0xdf, 0xdf, 0xdf,  // 灰.
                  0xff, 0xff, 0xff,  // 白だが透明扱い.

                  // Image Descriptor
                  0x2c,
                  0x00, 0x00,
                  0x00, 0x00,
                  (swidth & 0xff), ((swidth >> 8) & 0xff),
                  (sheight & 0xff),((sheight >> 8) & 0xff),
                  0,
              ];

              this.tableBasedImage();

              // Trailer
              this.binary.push(0x3b);
          }

          // インデックス カラー形式イメージの符号化.
          tableBasedImage() {
              this.buffer = [];
              this.bs_pos = 0;
              this.table = [];
              this.code_max = (1 << 12) - 1;

              const tree = [];
              const tree_size = this.code_max + 1;
              for (let i = 0; i < tree_size; i++)
                  tree.push({
                      code: i,
                      next: -1,
                      down: -1,
                      data: 0,
                  });
              this.tree = tree;

              this.bits_init = 3;
              this.encodeImage();

              this.binary.push(this.bits_init);
              this.pushSubBlock(this.buffer)
          }

          // サブ ブロック形式情報の生成.
          pushSubBlock(data) {
              const buffer = this.buffer;
              let binary = this.binary;
              let offset = 0;
              let size = buffer.length;
              while (size > 0) {
                  let count = size;
                  if (count > 255) count = 255;
                  binary.push(count);
                  binary.push.apply(binary, buffer.slice(offset, offset + count));
                  offset += count;
                  size -= count;
              }
              binary.push(0);
              this.binary = binary;
          }

          // イメージ データの LZW 符号化.
          encodeImage() {
              const tree = this.tree;
              const bits_init = this.bits_init;
              let bits_curr = bits_init + 1;
              const code_max = this.code_max - 1;
              const code_clear = (1 << bits_init);
              const code_end = code_clear + 1;
              let code_curr = code_end;
              let code_step = (1 << bits_curr);

              const source = this.source;
              this.bs_pos = 0;
              this.buffer = [];
              this.write(code_clear, bits_curr);
              if (!source.length) {
                  this.write(code_end, bits_curr);
                  return;
              }

              const s_curr = source.values();
              let s_data = s_curr.next();
              for (;;) {
                  let c_curr = s_data.value;
                  let data = c_curr;
                  lzw4: for (;;) {
                      s_data = s_curr.next();
                      if (s_data.done) {
                          this.write(c_curr, bits_curr);
                          this.write(code_end, bits_curr);
                          return;
                      }
                      data = s_data.value;
                      let next = tree[c_curr].down;
                      for (;;) {
                          if (next < 0)
                              break lzw4;
                          const ntree = tree[next];
                          if (data == ntree.data)
                              break;
                          next = ntree.next;
                      }
                      c_curr = next;
                  }
                  this.write(c_curr, bits_curr);
                  {
                      const node = tree[c_curr];
                      const next = tree[++code_curr];
                      next.code = code_curr;
                      next.next = node.down;
                      next.down = -1;
                      next.data = data;
                      node.down = code_curr;
                  }
                  if (code_curr < code_step)
                      continue;
                  if (code_curr < code_max) {
                      bits_curr++
                      code_step <<= 1;
                      if (code_step < code_max)
                          continue;
                      code_step = code_max;
                      continue;
                  }
                  this.write(code_clear, bits_curr);
                  this.clearTree();
                  bits_curr = bits_init + 1;
                  code_curr = code_end;
                  code_step = (1 << bits_curr);
              }
          }

          // LZW 処理の初期化
          clearTree() {
              const tree = this.tree;
              const tsz = (1 << this.bits_init);
              for (let i = 0; i < tsz; i++) {
                  const node = tree[i];
                  node.code = i;
                  node.next = -1;
                  node.down = -1;
                  node.data = 0;
              }
          }

          // ビット列での出力処理.
          // （リトル エンディアン）
          write(data, bits) {
              const buffer = this.buffer;
              const bpos = this.bs_pos;
              let idxs = (bpos >> 3);
              const idxe = ((bpos + bits - 1) >> 3);
              data <<= (bpos & 7);
              if (idxs < buffer.length) {
                  buffer[idxs] |= (data & 0xff);
                  data >>= 8;
                  idxs++;
              }
              while (idxs <= idxe) {
                  buffer.push(data & 0xff);
                  data >>= 8;
                  idxs++;
              }
              this.bs_pos = bpos + bits;
          }
      }

      /* **************************************** */
      /*
       * Base 64 符号化と復号
       */

      class GenQRCodeBase64 {
          static EncodeTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
          static DecodeTable = [...Array(256)].map((_, i) =>
              GenQRCodeBase64.EncodeTable.indexOf(String.fromCharCode(i)));

          /* バイト列を Base 64 文字列に符号化 */
          static encode(b) {
              const table = GenQRCodeBase64.EncodeTable;
              const blen = b.length;
              const brem = blen % 3;
              const bcnt = blen - brem;
              let s = '';
              let i = 0;
              while (i < bcnt) {
                  const d0 = b[i++];
                  const d1 = b[i++];
                  const d2 = b[i++];
                  const d = (d0 << 16) | (d1 << 8) | d2;
                  s += table[(d >> 18) & 0x3f];
                  s += table[(d >> 12) & 0x3f];
                  s += table[(d >>  6) & 0x3f];
                  s += table[d & 0x3f];
              }
              if (brem) {
                  const b2 = (brem == 2);
                  const d0 = b[i++];
                  const d1 = (b2 ? b[i++] : 0);
                  const d = (d0 << 16) | (d1 << 8);
                  s += table[(d >> 18) & 0x3f];
                  s += table[(d >> 12) & 0x3f];
                  s += (b2 ? table[(d >> 6) & 0x3f] : '=');
                  s += '=';
              }
              return s;
          }

          /* Base 64 文字列をバイト列へ復号 */
          static decode(s) {
              const slen = s.length;
              const table = GenQRCodeBase64.DecodeTable;
              const fdata = new Array();
              const b = [];
              for (let i = 0; i < slen; i++) {
                  const sc = s.charCodeAt(i);
                  if (sc >= 256) continue;
                  const cc = table[sc];
                  if (cc >= 0) fdata.push(cc)
              }
              const flen = fdata.length;
              for (let i = 0; i < flen; i += 4) {
                  const d0 = fdata[i    ] & 0x3f;
                  const d1 = fdata[i + 1] & 0x3f;
                  const d2 = fdata[i + 2] & 0x3f;
                  const d3 = fdata[i + 3] & 0x3f;
                  const d = (d0 << 18) | (d1 << 12) | (d2 << 6) | d3;
                  b.push((d >> 16), ((d >> 8) & 255), (d & 255));
              }
              return b.slice(0, b.length - (fdata[flen - 2] >> 6) + (fdata[flen - 1] >> 6));
          }

          /* Base 64 文字列を 16 ビット列(ビッグ エンディアン)へ復号 */
          static decode16be(s) {
              const b = GenQRCodeBase64.decode(s);
              return [...Array(b.length >> 1)].map((_, i) => (b[i << 1] << 8) | (b[(i << 1) + 1]));
          }

          /* Base 64 文字列を 32 ビット列(ビッグ エンディアン)へ復号 */
          static decode32be(s) {
              const b = GenQRCodeBase64.decode(s);
              return [...Array(s.length >> 2)].map((_, i) =>
                  (b[i << 2] << 24) | (b[(i << 2) + 1] << 16) | (b[(i << 2) + 2] << 8) | (b[(i << 2) + 3]));
          }
      }

      /* **************************************** */
      /*
       * UTF-8 からシフト JIS (CP932)への変換
       *   ECI \000020 に CP932 は含まれるのか(?)
       */

      class GenQRCodeCP932 {
          static MODE_KANJI = 0; /* 漢字 */
          static MODE_KANA  = 1; /* 仮名 */
          static MODE_CP932 = 2; /* CP932 */

          /* UCS から CP932 へ変換 */
          static getCode(c) {
              const S = GenQRCodeCP932;
              const h = (c >> 8) & 0xff;
              const l = c & 0xff;
              const p = S.VALID_HI_TABLE[h];
              if (!p)
                  return -1;
              if (!(S.VALID_LO_TABLE[(p << 3) + (l >> 5)] & (1 << (l & 31))))
                  return -1;
              return S.SPARSE_LO_TABLE[S.SPARSE_HI_TABLE[(p << 4) + (l >> 4)] + (l & 15) - 16];
          }

          /* CP932 と QR 漢字モードのコードを返す */
          static getCodeEx(c) {
              if ((c < 0x80) || (0x10000 <= c))
                  return undefined;

              const S = GenQRCodeCP932;
              const s = S.getCode(c);

              if (s < 0)
                  return undefined;
              if (s < 0x100)
                  return { mode: S.MODE_KANA, cp932: s, kanji: undefined };
              if (s >= 0xebc0)
                  return { mode: S.MODE_CP932, cp932: s, kanji: undefined };

              // const t = s - ((s < 0xe000) ? 0x8140 : 0xc140);
              const t = (s ^ 0xa000) - 0x2140;
              const k = ((t >> 8) * 192) + (t & 0xff);
              return { mode: S.MODE_KANJI, cp932: s, kanji: k };
          }

          /* 以下、変換用テーブル */
          static VALID_HI_TABLE = GenQRCodeBase64.decode(`
            AQAAAgMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBQYHCAkKAAAAAAAAAAAACwAMDQAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAADg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5P
            UFFSU1RVVldYWVpbXF1eXwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
            AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYGEAAAAAYg==
          `);
          static VALID_LO_TABLE = GenQRCodeBase64.decode32be(`
            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
          `);
          static SPARSE_HI_TABLE = GenQRCodeBase64.decode16be(`
            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
          `);
          static SPARSE_LO_TABLE = GenQRCodeBase64.decode16be(`
            ANAA0QDSANMA1ADVANYA1wDYANkA2gDbANwA3QDeAN8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwCwALEAsgCz
            ALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/gU2CgYKCgoOChIKFgoaCh4KIgomCioKLgoyCjYKOgo+Cb4JwgnGCcoJzgnSCdYJ2
            gneCeIJ5gW2BX4FugU+BUYGXgmCCYYJigmOCZIJlgmaCZ4JogmmCaoJrgmyCbYJugk+CUIJRglKCU4JUglWCVoJXgliBRoFH
            gYOBgYGEgUj6nPqx+tj66Prq+1j7Xvt1+337fvuA+4L7hvuJ+5L7nep76b+NlJa3++nqfOpC6cLqfeJmjO/pwJPb/EiWUep+
            6cPqSumPkpPpbYvukJGO7YntjYOZ6uls6frp+elqjvnpa+mQ6WnouuW06LuQa+i8iUKX7OVll9fot+i+6MDoqeesjMDoqOWy
            +pD6m5HJ++zomOVmlY3m9pXD6J3on+ie6KDom+iZjX6W5eia6HiRTeb05vXm9+h54n6Vwuh6ikrob+nk4oCJW/rg6HCJTehx
            6eXnW+dd4oPodOhy6HXod4/5+9joQehD50P714vR516VZOdK6GSO4JhC50Xn/I3259iL4OqekNboYul059n7u5NC6Xb7uufc
            ipiQavu859rn1OfVi1LpdepZl7SUzo3Rjt/n1upY59eXoo9kluyXyuex57DnruKEitLk7o1m547i9eez57KJk5Frl8aMree0
            l3nk2Pu156mTS+L34sXqTJGYjtXnqpKA55PixpL8k3LnlOeYkIDiy5SHksrqROpDkMDnl5Gskd6Rl5hEk6bqReeQi3SJTOpA
            6kGSTueZidvnluejk6eSQ5BKlF+U7pJ5k+mLYueI+6eSspXTktKNnuloluGSSObF5saLTZBQ5siUg5Hd4dKbTZTvk1zmxJXY
            lmaViY3gjXaM24zi6orh1JVuid2UzObDitGQ0+bC5seSmYtj47+P9+Zf5qL7o4xQjOzoSOZekfWLTJOr5qPmYfus5mLl+4/X
            6XqMTOZB6ErmQOXc5d7pgOZDjNHl0uZCiL/mRJCKitjl0+mgntPl0OXdko+RbOqL6Ome0Itz5dHlzovc5WmZfJ7Ej07qjOTI
            i5WOqpe4l4mL8eVqltbkt5XslWbkv+Sk5OWNnInY5M3kp+Ry6YyYrpGQjHT73+RzldyK2olgjK6RQ4935FeVkY9NkVboSeRY
            j9+VjORa5E7kXuRP5EvkW+RZlF6Rq+RMknLkTZ+JjZjkRubljXDkSp+R5uSfipKwlaCRQpKn+viVheREkdrkQ41vmHKLk+Pg
            +57j3+Pekq6LsuPhkEXkVOPi5VblVIrC4+OYV+Pk46PjpJL3423jpuOl42mMSuOnjqOV0orJ6EySt5bJ46jjiIjc44zji+OP
            6FDjkeNmjWqW1Ij2ktTjXJJj+4zjZOLY41mSXeLV416Iu5bI+42ameNh41uPyuLUkNDqj+LX6pDiRONfjviI2+Na42KN15Fi
            40eQYeqS40mRZpZhjfWP0I2ulp773p/h6HbjSI5LjoeS25Db40aX3eLilKyXsef5n+2UlOLZkWWUU52X4taPbOLdm9Xi2oi+
            kN/iueWl++SUzeLb4r2V0eKSknqb0eK44rqXWouj4ruZXpJ8jrGPzeKO4o+PdorGk7bikPuF4nSKmZJH+4eMiuKRi4aSW4zT
            4nWL84j74+/ido2SkPqV5OJtkY/j3JZzlEjj9uJv4lnj3ef1kM+Jbom44lriW5f86beL14nRk8PiaIvW+sqVQJhckVTqjYi8
            /EOdlOJTloCMuYnQkvWVn5dTnZWPgOJQn+PiT5Fj4kyXrY1h4k6f8OTxj2qQX+JN4dXnveDxk7Xk+I264dbk8OD04dfhrOHb
            4dnh2uGt4djg9eqJ4a7hr+Gw6d6Xoeng4YKOTeGE4YWSc+Xpio/py4lWlmjhg+ni4YCI2eF94X6P9OFmkWrhY5Pr4WKIopHL
            iOiUqel5lUyLReFel6qMbOFfjXjhXZTU4WCYWeFhl9r7b/tr4PLqootdl5Dgt5P74PDg84qM4LiWSuXu4OXgp4yi4KiKo5TG
            jt2Vg/pd5frl8Jbq4KngqpF1jqLgq5fTi7Dglo1Q4JiJjY+a4JONipRHnJmci5+36F76vJp6nI/oX51Ml5TgXJ1K4GCR84uU
            k26dTZ/Un92IrYlR+0iVr4m36pyf1pGqn82fz41gl4TqneJz6XDpcZ/Gn8CfvY27jqzpc5fSn8Ppcp+I+0KKvo944eSJmJqG
            +vaT8J+HjV2fXpqFimSKvZ9gmoeT7Z6+k+ifX5qKn2HpWOlZ+umfYp7CnrWevYvGnriPfJPM4G+eouBx6eaeuennnqmenJ67
            nqaS1phvnpaeoOBwnqSI1pNmjPyemJBYnqqWuJ6dkEGSxZ6TnpGMTo+9meXlrovhmuuM5peci5KKZ5eG5bGeiOWokvKLy4xL
            +uOKuotqioeQQJ1onW2egvrkkcaN95aRlb+OVp51mGeeZZCVlUHo6pRCnmSedJSQnl/nWZ5ek4yd3J3gjM2LbulFlGbnWJBn
            51rpRp5gi+uPvJTCnlmP8JbbnlueXJeI+uGPzI3ekbqeYY7bl1eNWY/xlHSNxZ5aiNqY8JNtnveeWJGpjI6XTOdIlfyfQJWe
            +t+eS55InneLyIlnjVieSeVjnkqPkZGC+t76ZpnWkV2RXJHWiWaXlubi4br61I904KKWho3whJ+EqoSghKuPuvrSkKX6zuCj
            jVad3uZWhKGNqY+4hKz60Z3d5IqPuY16lr6NqJTjlMGVh/vN+86Jpo7Fk2zkjJe/lmedzY7O5fyL3Z3OnamdqpNGnazlpJ2D
            jkOdp5G1nYmddp2Ei1uRfJ2Gna3qh+qIjvade5Vg6XePtpNDnXWdep1E+2SdRZ1GkdX7Yulu6W+My+pR6leW3+pQ4OLqVZZb
            kKyJ5In6+sec+/rFiL3qVuS+nMaQypz8+sTmwZ1AjIGb0JzEnMecv5zDnLWPROJDnLiUTZvSnLKb05b6lvn7lOJC4JScvJy9
            iNOcfuCVifick5yVknCYbYqhjaaJtpyNnJicl4ux5VORp5HTnH2XlZp55VWLfZyIkKuJhZyCifach5yrnHmKmouv6G6UT+aW
            5+OceI+yiWWcdpxljZrmmpx8nGbml5bw5pnmmJTek/OcVZxpi3ySooj4nFaVpI1P6ffivpJv6facTJxKku2cS5xNiZWJhJLs
            nE7p9IyaifSUVZv7nE+T+Ypm6UjpR5xA6UmTu4usnEOcRJqsnEKN4pVfieObtJu5i8+PyZu3llaV9ZNqjsaaqpqtkXeXmvvC
            5+XmsuGJ5+Ln5Jui5rObo5PUi8ebm5PYkOjn4IuPm5zg7ov8jFSTzYmumcWOcpudm6CbjpnGiUubkIrfkp6bj4rHkKGbh46b
            iqaL9ZuGkc6O9ZJc+qmaxpD7irCS55BRm4uOQI3J4emKrIpRiYOPqonG6p+bgpdl+3mbfoys5lubgI9oke7mXIlGjueIwOdi
            kXaKro6zk+6NR45xm3KRm4yxjUWbc/qmjpqRtul4m3SbdY55jUaam5bQju+V3pqdn/mf+5CWmp+anodlmqCRUZqhjaKMl4jN
            kH3gQJ/3h2mJyJVimpqMxeJdmlCNkZTpmpyR7ZpVj6SZ8OmNkWTlkpnymlKZ9OWTluKKW/qSje6YYemOmemZ54jziuv6jJGm
            i3CXkZGgmcmJtY+gi6eZyJm4+ouVwYuokvOPYIuBlNn6iZbmk/Xlo5m5le+ZsPqKmbGd25TEicHlrJmzl/KZteWm+oaJoJ3f
            j5WTd42FmaCZoYvo+3eP6JmbioSZlZmTkW7pfYvf6XzpfpXU6XuZYpmXmWOZlueJk+CJfumC+/uZZo37+3SZZY3E+nSZZ/p6
            mO7g05Tn+niY75jziMyY3Jja597n35jVlc6KRJGtmNjn3ZjbmNnn4ZXbi4SY1ougib+O3I3Q4MeBeYF6gaeBrIFrgWybRJj4
            lpmVjozymM+Y+oeAicCHgZW5mMn6a4rpllT6bJjNjPHg+ZD4jmeYwojJ4PrjcozeiuqVmo9ZkG2YvJDOmLqUm5i7i3eOyON0
            jaGJ7uHjmLmYuJWng4CDgYOCg4ODhIOFg4aDh4OIg4mDioOLg4yDjYOOg4+Db4Nwg3GDcoNzg3SDdYN2g3eDeIN5g3qDe4N8
            g32DfoNfg2CDYYNig2ODZINlg2aDZ4Nog2mDaoNrg2yDbYNug0+DUINRg1KDU4NUg1WDVoNXg1iDWYNag1uDXINdg16C3oLf
            guCC4YLiguOC5ILlguaC54LogumC6oLrguyC7YLOgs+C0ILRgtKC04LUgtWC1oLXgtiC2YLagtuC3ILdgr6Cv4LAgsGCwoLD
            gsSCxYLGgseCyILJgsqCy4LMgs2CroKvgrCCsYKygrOCtIK1graCt4K4grmCuoK7gryCvYFAgUGBQoFWn/OBWIFZgVqBcYFy
            gXOBdIF1gXaBd4F4hLuLmuJVhLGEqOJXkmiEuIS94lie+oSzhKmEtejehLmEsISnhLye+IznhLeP4uVrhLKEpujfko6EtodA
            h0GHQodDh0SHRYdGh0eHSIdJh0qHS4dMh02HTodPhIKEg4SEhIWEhoSHhIiEiYSKhIuEjISNhI6Ej4SQhJGEcIRxhHKEc4R0
            hHWEd4R4hHmEeoR7hHyEfYR+hICEgYRRhFKEU4RUhFWEVoRXhFiEWYRahFuEXIRdhF6EX4RghECEQYRChEOERIRFhEeESIRJ
            hEqES4RMhE2EToRPhFAAcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwBgAGEAYgBjAGQAZQBmAGcAaABpAGoAawBs
            AG0AbgBvAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwAw
            ADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/ACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AEAARABIAEwAU
            ABUAFgAXABgAGQAaABsAHAAdAB4AHwChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4Ar4KQgpGCkoKTgpSClYKWgpeCmIKZ
            gpqBb4FigXCBYIFJ+leBlIGQgZOBlfpWgWmBaoGWgXuBQ4F8gUSBXup2/EuNlemh6nfpoujj6OTg0pbZ6aOR4ep46nrqeepr
            6mmYW+D86mrp3Zft+2bp3Onb4Oeffeps6byX2fpajLuVaOnZiPGZ8+m9me6Wjo5MgfCN+JFO6biVqem25uP6kem56bqKQI2w
            6a/prpaj5uvm6em76ZHm5umS6ZPpsemy6bCNgvv8k13nY/xAnlTplOmV6VXpUZ5X52bpVJCZ57z7+IrZ+7aXm4jH6VaOYOlX
            6U6J7OlPlcWSuI2g6VCNgI+Hl2uQe+lS6VOI7Ojx6Nmf7ujwipPo1+jbn+Lp4enfkkzo3J/oiMboxejdmEn77eLAmdPix+LB
            nlDoxuLK++6TRejH6MiQnYrl4Pvi0JdZieuPV4zZ6JTos4la6LKOk+i06LHoleVQjePoWJNMkI3oluiX5VHoUehS6FX7fJCO
            6EDoQuhX++P73fvb5+/7yY6m5/eX5+f2jtDn5/vF+8jn9ImUk1Pn6Ofm4dHn6+fp4dDn7pZ2kfL7x+eg56HnopO5kkKI4eem
            lpfnp+qhn5yVl5G76UPnqJPZkIuJ+elEkniJZIv2m2rnpJdWiV6bbZXVid/nn5Gi55WIp5hBm27gmpDV55rm75uzkYeOV+Cc
            jNeR3+bs5u3gm5BDmdeYSInq5sqYR5LAmGTkeOakjpHmyY5dka+bp5L45tqRR5fAncyejOallH7mppZkiXmI4OfBk6PnwJ6U
            5omeh+aD5ovmhOaI5oCT5JL65n7gd57hnsPmfJ7Wl0COkIlylkLmbYx3ns7ggo6Onsmexo6Nk06YbOZs5muRRo28kcDmZ5pN
            j9mVXZpKjL76lJL55l3mZptpi16OjIx24WqQdeZN5mCWuZOi4WvmT5eX4WzmTpBll3bmUOZI5cHmUZWilGXmSeXC5kqMqeXD
            +rLlxYtLjdmX9OXf5eCRleWVm8mbxuWgm8iMi4najaXlnJeg5aHjTOT55UDlnZTX41X7i/vMjWnk/I/UjsflQpFLlcyLvJag
            5Pfk9uj05PLk8+jziVWVkuTik5/7ueT1iK+WapOq5NuTQeTXkZLk0eTZ5N6JkeSSl+iR24uZlVmVY4eU5J6OvYnV5JyNl+Sa
            5JHkYYeVkZ+YUoHlgYeHmORj5GLkZee+jNKOiPu45GaU7JqI57+UWIyolmKai+Pt4+v7kY1t47iMUZhomrSajJFBi2Djqepa
            kemN6+O847nqXuOs46rjq43fjHLj0uLvknXi8ZBOl7Xi8OPT+4Sa8uKKjNDiiZqyldaRV+KL4oyexZez4o2eyOjt4mmI7p/0
            l2yWip/64myLSJ7NntfiaonSjG3ia41l4mKOSIiqkvbhqeJjkMXhqJqJ4m7hquGr+3P7ceGj+3L7cOGkk0ngc4pGjWPhpZpR
            4Z7hpuGfic7hp59S4aCTlOGhn1OUrZNv4aKUkpVTjZmJVOFRn1XhUJufi/uKw5uekHKTV5NbkpjhUpC24UCKi5Va4UGRro7s
            iqLhQvtj4UPg4I9QnUHmReFEjF3mRpDtlMfg4eDfnUKJz+ZHkLydQ4tZnITg2/thjljgZeDjkr/g3ZVtnIrg+OBt4YHgauBp
            4GbgbJPS4G77TuGI+0/hhuBi4YfgY+BH4EbgTOBnkJ/8R+BD6kb7S5ZBlGeLg+Vsk0TgT+pLko2fnZ+jic2T+JpFiLifoZWm
            lvufn46hj8CfmJ+eiYiRv+e3i4KfkuTv57iaypSMk0CS04yIi0Kfd4tEn5Dk9Ij8n3iKcJXqloifc59yn3SJo5Jp5lefdeZY
            5lmORYprn3abpJlTk2GfY45+kLONn4ztlZCQwZdEleCYY59JlK6YRZR9jpWe+Y9Ynvue/J9Mi/mbWpVRn0ifSp9L5NqfR+TV
            no2ee4yFjGqTjfrmj9OeeZKMiMSW9o7EjfKJXJ58nn6WXoq5jbiQ9Y9flo+KYJFYktGaeJdNh3SO6Z5wnm+WcOP6nlOeVp5V
            h4OK9+P5+tuLgJKonlKEvuP7l++d6I6ejVed5o5i49eEtJXpnefj1pBX5836Y4/dneWd453hneL7QefQ586KVfrQkovnz53T
            nkWd0Z3Ul7ed0oj5h3WIuYi0kPmd1YvSkMuRsJWAjpSWT4/8nc+OYZJmnWmOeoydl56dbo5BjYmItZXE+2zi4OD2lX2PRZ1c
            lOGPip1HnU6W4J1Rj7PmkJDu57uU4Jz2juiL3o3LnUjld4H85pSc95z4lejlc5z6nPmPXojUnNObT5zKnNCc14xjnMv6w5a6
            gdybUpyxm1CXfIimm06L8IikmGaI95ypirT6wI5w4ZCcr/utjZvhj5DJ+676v4jSnHGM5OGR5s/m0I135s7lV5xylZyPeoeZ
            5Vicc5T3j5mcbJNrj13lW+VZh5aTvpxwnG+JSfq3lpiQdpxulu2Mt4zKldmcV5xQmE2MfZxYlJqcXpxRlb6cVJifmK/goY6u
            m/ib+ZRwmpOakZqPmpKb+pf1mEySoZqUjUyPr5v8lrOU3ZqVm+qPsI/Fm+mb6JWdj5ib8YrT6GeW+IeQlnn6tpvrm9ub2uhz
            6Gmb3PxC6GzptfxBm92bwJDsj0KbwZu7ilKbvJvFm8Sbw5u/j0HqmuWqm77lu+qb6pmbmZuajtqQS5PykHOU9pRBlZWQ6vpZ
            jsubkY+rm5Kbk4jRkbiQcY/sm5STsY+smvmBjpr4+qObbImcktqa+o+nmvySRJrZmvua2JWxjYif0Zramtya25/Xmsma3prF
            mtOa4JBvjsGYcI68ms2ar4yb5M+auo9tia+au/qa+pmc6ZneloSYQ4q2j+mShZXwlmmS5ozgjZD7duHHlNuZ5pJFmeSUXYrc
            md+Z4JnimdySr4toimXlZ4zV5EKNh4tnkt2JRJOvlryNQJeZiWKRcIz7jMOL5Yty4/iZ2ZJAkfyLqY+imdqZ2InCmczow57B
            ilSWtpnOmc3oxJB+iViZuo3lmbuJfZnPiXzh05m8lUOL5ojjlcuZnZmak72ZmZTy48qPdZfEkEiTgZfN+oWQbpmDjPeVqpDY
            iqDgdYqnmYSZgIpNmYbm4eB0mYGLpZK0k8qJmo9vhHaJepSfmYKZdZlzmXSZco3hmXaW6Jfi53LhyOHLlHmX1pl3+oKZWYjy
            j1OMs4xaj1uSm4uikOaM9fp+jY6ZW5bGk2WY7JN85UGY4YRGjPTlYpFojPOY3+Vd5V+XyPp3jtiQTZhflpOY3Zje5nvmh5Kz
            nO7mhvuonO3qTY9DmOuNspdD6k6RzOpJib36bpjH6fKXXZjDmMWN7JjGm0OYs5ZTmLTjVIzwiOWWkoGAi5zjVupli52LnpLg
            l7qJXYzd6maM3Ijk6mfqaJhqmGmby42xiJ+bzJixmLKLVJeSmKqbx/qwmKuXuYF+l1yRiJitjpaT8Zu9mLCYo4v46JHok/tU
            mKTokorbkk/ggY7lmKWYoIlOmKb7U4qOmKGQopnAi3WVuIjqkpoAAI61j+WXn+F7lpyP5I5Pj+OJupGJlXOXXoOQg5GDkoOT
            g5SDlYOWjETngOeB54KBRYFbgVKBU4NAg0GDQoNDg0SDRYNGg0eDSINJg0qDS4NMg02DToLugu+C8ILx6ergtQAAllCWwuC2
            k86BSoFLgVSBVYKfgqCCoYKigqOCpIKlgqaCp4KogqmCqoKrgqyCrYeXmPyZQpj7jcKBYY+dgciByYebh5yHkoHojFiHk4O/
            g8CDwYPCg8ODxIPFg8aDx4PIg8mDyoPLg8yDzYOfg6CDoYOig6ODpIOlg6aDp4Oog6mDqoOrg6yDrQAAAAEAAgADAAQABQAG
            AAcACAAJAAoACwAMAA0ADgAP+5/7oPup+7H7s/u0+7f70/va++r79vv3+/n8SfxG4dwAAJZD6diUaunU4d3p1enR6deTdunT
            ioLppOmljXvppgAA6afpqOmp6aqfbumW6Zfpq+ms6Zifb59wi1GUr+man3GVRemb6ZnpSupI6UvqR5mqn1qU0ejsibmMe+jv
            6O7jceN343CLZolDj2Po4paQi7/o4ZZE6OCX2I9r5pHp45Xa6M/qcpbK5nPo0JC+6NGSYejSinaXVejU5naQePvykMKM6p5E
            +/OW9eD3+22Qw55GkFbozp5HlPHozPvv6Mmd0OjKlfvoy+jNiZeOe+i/+/DovfvxnbPowZTW4fTowp234feRmolBieDoopLC
            4kGXy5Op6JyXpONsjK+X++iAl3qK1op0jX2UtONr6ILogZVlkpKfhp+F6IPqW4uY+mXn+vvZjXz71epc+9zqXY+bn7SfsvvP
            lWzn+JXdiann24lzkt77v/vAlnSL+upzi2/qdOp15637vfu+j4Xnq5FKkUmPrYjim5WXyeevkOuU8I9UkGmPrgAA55znm/qr
            iO3nnZSgj3GVTuK856Xnj+BylKKWwOee55HnkueLk+WSx+eKid6fUZ9Ok/TnjJSXkrWTUpFI543na+dtlePnauVt5vCOXOds
            5vPncOdui1CUhedvjKvmzObLk/aVipVvkdeflo6/iWrmrZNx5s2OXo6Sk6SP3Oav5o2WTJFS5rDmguax5ozmjo/EjKrmio11
            5oGO0+Z95lKKz/uq5oWPlAAAjL/meuZT5niR+OZUkmvmVZyDnImQv4rQ5nmSiZB6kL3mcpx35neM6+Z05nX7puZxifWe3uCR
            kOCTx4yM4JLlx57d5caSzo9PkYXlhp7blknlh41zn6XlhAAA5YXliuWNjsKKl+WL+5mTxOLD4sKP9uTj4r/k6JGT4FCYVeTk
            jNSVSOTJisDkvQAA+5fkxuTF5Ynlg+TQkJvkwfuWAACSd4tl5ZSL25ao5MD7k5bO5JeJ1oqd5JuXk59P5J3khZBG+4Ge3Ixz
            iZDkhuSH5ID7g+R+4lSKzeSI5IEAAOSC5IPkbORtja+Xx+RujILkb4u7najkcJ2dkOPkcY7J5GcAAI6ZkGKZWonnmVzkaJfV
            5FyOqeRdk32PTIqVibAAAORk5F/j2ImAmqLkYJC5mqTj2Zqj49qOW+ONmqaVt+Pbk3njkuOT+lyfgeOUAADjmpNa43PjgI6B
            iKzje52F434AAON844Hjep2C42CQ0ZfOj4+K9pV14477jprB42fl2ZD85dvjY+No42qXjYi641KU7QAAi4vl1+NPj0mMvJFn
            40TjSuNQ+4qbZZtm40WMb5b8403jUYtJlcjjQOGWlvGNZ+L84ZXi8wAA40OW5JOclFvi8uLr4uri6eL06FaVs5GM++Li7ehZ
            nu368OLukLji5+Llnu/i44qfidyPz+Lo+vGKgOLmmoLi5OLs4rSSSpSTlqXmrI5a4q7it+Ky5q7iseKt+4jir+Kekn2Tm+JL
            k5qUSY30j86Py5q5AACVW5q24rbimOKZjdWTSuCP4pPimuKg4IfiloxGi4gAAOKV4qLgjZKCkYvilOJ54nvieOJ654WXWIzp
            i72Zn5mejEHh7JL0k3PnhuOQ54fh74pW4eqW7uHh+1mSbZRSlIqWSIvpmECTleCXklrh4ou44bbgmYrElNXhtwAA4bjhtOhq
            4bnoa+Gzk5CW2pSwi3iQt59Y6G3htZa/4XaU5uFwie/hcpjlk2DhdJBdAADhaeF14XOOvuFk4WX7UeFo4WeVRJhGkIaRYZFg
            +26JiuFL4UrhTAAA4OiX1IvVlPqUaeFN4U/hTuDp4MHgwuDAiPDg6+SJ+1vguuTMjuvky4/zk8aLt+C5kquMkpSL5NL7XOTd
            4K+J5Zj2i43gX5bE4EqWtPtN6Imf+Omzk0jgZJaC4EKf9eBo6bQAAIubktef9p/eiorga5/mn+uf7OBFn+rgRAAA4E2Xbp/l
            keqR2JNNklcAAJ/nn8n7Sp++kvGfxJ2Hn8uI+p/Bl0ufzI9pn8WXZ4q3n8qfrZtxk5GfyJtvkPSbcJ+qn8KXjI9HjoSTtJ+k
            k8WfeZTkAAD69OJclPmPSJ9nltEAAJ9pn2ifepZ3nbmduI99juqOY/rtn2qdmJ26na6Pv57ujnie9Y73ipIAAIx4kk2WzZ72
            nunmnuagjria7+ahjKCJoYp+iM6a8J7Rnuee6p7kklGa8ZKUicOVV57Hntqez+LEnuKPvuqg4tzi3p7MjVySxpGEnsqWX+Lf
            np+eoYvynqWemZ5xkkmeboljkM2edpOPnmwAAJaNnmqX0Z5ynmiWh4qeicqOffrc5OCWXOSm5M6Ncp5Bnfnk05eOnfyRkZ37
            +t2LxepinfGd9Yyy6mOJyZ3ynfTqZAAAjq2d753znev61YpBneyd7ZTTiVOOTo20kE+VgYxp+tbl9PrX5e/l9ZpIneqd6Z3u
            ndmd2or55fnotZP6klWLjI58kYGLfgAAj3uIrp3DncKUc53Fi7MAAOaPl3edx53GnaadseaSnbDmlZ2vAADmk5VUnbKXaZ2l
            nbSP752hlHKdovxEAACddOm+jECRgPrMinzpwQAA/EWdfIn7nVmLkZHxnVWfVOmtnViNU5DZAACPtZ1glHGdY+L2i1OSU51d
            nWSdX51mnWKL5J1hlI+MkJ1bl32dUp1TnVeTip1UjVKQ3ItrnvKdZZSykqaR8Jzxi0Cc75zljJybsJzwm7Kc9JzznPWc8pad
            irUAAJzSjuOMZIpT+riSo5zPi62cWZe2nNGco5VKifeSZZyhnKLksgAAnJ6coJyBiO+Te4zl5KmchpV8AADkqJyAnFqchZfl
            jnb6Z51vAACcW5v3i66V35xckrucXZN4jcDlmpF7krGMyeWXkuuKsZW9lE6b8pvzlIiNS4qym/SMtpdjl0iK9Jv2i0Ho1QAA
            kqCMQ5jOm+ab54/t6Nbo2pjR6NiWWIzIm9+WpJRim+Dln41KkEkAAOWbiqrlnpJGi9CPhJ/akYPllo1IjbaNSYuQlqmV9Jve
            n9if3I23+q6ThwAA+sGcuZu2j3OR0Ju1inicwZzAm62br4rdnMX6rZusm66blpuxm5eSuZbe6egAAJS1m5jp7enpicebiovE
            m4ibjJuJlEqey5BS5Y6bjfqq5ZCXvpr0jF/lkfqglnqa8+WPk4Wa95rnmvb6oY9L+qLjxOPDlc+a6PqfkLqI65SEicSLtuC7
            4L2S2eC8muOa4prkmuWa5pFZmsvgvpOD4kbiRZNok4SUt5LLiYGV8eJHjceP6pNnAACavZq+mryN5JrAmpaazJqXjmuab5RX
            mpiZZIjmjvqObJfDj6WJ8ZpZ4ZThkuGTh2eaWJpPiuCI9ZpOh2iRwZpGmkeJ2Y+jlomP0gAA5MOaTJpLmfaN2JpCmfiTcAAA
            mfz6kwAAmkCZ+ZntmeuaXZahAACZ6JnxmeyNlo6CAACZ74zElr2U2pGykeyLpuDQ4NGT7JJQ50yUjo9Slm3nS5nEmb2PXAAA
            kOfnTZm/mb6PoYzfmcGUvJm0k8uZwpDejfOZtom7lmvid436mbeMTZmskXiZrZdv4JCZrpmvjtnqpAAA6NOM+Zbck66Pbpmm
            iqiWsZSh+ojh64+fmaeV5fqHmaT7e5Z14e2SugAAl0WX45XXh2aYSpmjmaWacIdujPiZe5Z9maKaaopOmm6PiJH6mmyZfZPi
            AAD6g5l+4+yZaJZgmWmf8ZlqmWuP54rBjsqW1+nE6cX6genJmVWOSQAAmVSZV5lWkeKO8plYmVGZUJlPi6GY1AAAmVKWbJlE
            n1z6fY+el7ufW5lDn12ZRYvNicyeg5JWmUCZQZVP+nmTrY7DkZyRpJLji/SUq5j35+qYxI/e+8uLVZS6+/WX4IzakEz6bY5m
            6PqOl4m++mno+5Hjl9+IyJinlFThbot24W2Vu5fbmL+JvJRWiXWT4YzBllKEoonymsiErYSkgaOBooSvhKOBXQAAhK6EpYS6
            gVyBpYGkgWWBZo2/jUKBZ4Fo6pPqlJfu6pHl1vqW6pXqlpGz5dXqmOXY6pforOiq6Kvlz+itAADorpfq6K/osIl7kMeUufxK
            6l/qYAAA6IbqYeiF6ITh8OiHjFPnuZXJ57qQ1+Hyk9+VlAAAlk3h8+e1inOO14ur+3qazud357aKjed253uXsI1k53rnc4yl
            53mTUed8l0HndYjQ53SIoedO53iXYOdR51CbUedPAADmuOdT51Lmupb05r4AAOa55rvmwJZl5rzmvfurikyS5eabnY6Or52S
            5p3mnJWIlMCTi+afi2yYYopZj9rl6o/W5ej7ogAA+6WXh+Xl5mqba+XnkLuQnuXN5dSbZJth5ciPcI78jFWO9IpYkdzlyeXa
            iXHls4/V5coAAOW45bn6+opJAACLYeVulGHlt5dtn67jtOVv5XDleuVS5Ufjt+V05UvjtuO1iZKJ1JPjlkblTOVP5OqWqox8
            i9oAAOSN5O2J6OTr5Obk6ZJ++mDk7J2MAACXdeThilfkluTnkbnksZ2Th2DkuOSt5LmHY4nXis7kr+P3iazktpO34ID7lY6o
            i7ngfpbr4HzkRZRcAADj1ZHPkl7jzuPUmcqNa5bvltXjz+PQl3OYVuPRjWzjzI7S48uKy+RI5EnjyOPNjqeBio7ugYnjyeRH
            lnyXg+Ou47DmZZeF46/jsuOx5miXcuZp47PjlpT845Xjl+OYm0fjmZC1jm/gsI5u45vjnPuPk8GQRJFV44SMoeCx44bjh5dK
            AADjg+OFlMmc2uN9k5ic3uN44lHjU5GekUCMceJSj0qMcJGx41iRjppTl0LjZZOd407jS5WsikeQ4pVSk9OMppS2j4PjQuNX
            jtGNaI6Gi4mVtONB4viKyuL5453i+uOejoWQ8OL7jG6QsoxJi4qLzIxI4uEAAIxmnniSzZ19lbKKfZCIAACWrpF+kHmVhJ2B
            4pyKluKC4oGR5uKF4n2QseKGl6eW0+KHkrziiJ6oiruRigAA4Xnhu46kja2PgpSok5fhepTIksmNw5di4XyXr+Fc4VqSe5Ck
            k2OXUo1ikFyTyZ7xAACSapmynvOSrInm4VWOWfruiZnhU4HLl3CBzJH0leHhVODm+2f6qAAA+2n7aOCsgYj6W/tqj5eTeuCt
            ldCUxZtAgeTgrpR24ImNRJSB4IXgiI/GlJmUz4q/l/jgjIH0js+Ma4Hzn7qB8pafktCf0I+NjLjqT5/fkt+f2Z+vn7HqU4lZ
            6lTqUo1fmFEAAIpcAACVgvr8j0afrAAAn6ufpoHxn6mBjIGNioiax5+olGifjp+Ll4CBpomW+veTVZK+jc6X8AAAk9efjJ9k
            n2WMWY6Al36ZhfqEn2aX8Z9Xn1afWYtcAACPiYvUiryKQo2rAACegAAAnpCKgYiynomejp6SjVuTjo9iAACei4+Lnorg1Z6G
            4NSSZ4jDnfb62ojVkMz6z533i3GQ6Y66l0ebgZ3kAAD605Cvncqdy5Dvi3uWb5W2m3yQxJfm4NyVa4pojdado52ejlSdmuDe
            nZn7YAAAm+2Wi5RRm+wAAPrLk7OXqY3MklSdeZvukNoAAI1UkISJhpFbnXeLZJX45fGHcodzku+V5uXy5fOWlZGdnVqJn5KK
            nNaSxJXn+p2a0JzMnM2czud9nMic1ZzJnNTnfpy+jpyNjJzCkdSNUZywkFScmuHmnJ2cn/q94ejiSeJIjrv6vpylku6cm5yM
            nJaclOptlJ6ckQAA6m7qcJyQl/bqcZySiZ2QqpxonGeMYZHSAACcbZxrkm6capeljOOcY4xgAACaqJqplUb6uZqrjcqVVpKk
            lWqcZJxf6E+Tlo29kZmcYJxhksicYonFm16cU5xSj7GcRpxFnEGOuZvkm12MmZxHnEiSnwAAnEmb45vim+X6p5LpjuKbg4rx
            k9CWp5uEAACbhYi3jMaVeJCpiM+Z0JtG+o6MtZtLm0yZ0ZtJloX6pY3Ii44AAI+om0GUQJTcls/pnYGagZnpnJaylETpnprs
            m0qR5emfk1aRvpV2mu2a7ombmunlwOW/5XkAAJdbik/lxJnHj2eRvZrqlun6npWtjvHpY+lkjYGa1ZrPmtKa1Pv6mrWNpI1D
            il+at43nilCJ4eVx5XKauJn3+piOUZnSmkSI9JpDAACWlI2zi3mXRpFvlL2O+/qN4cXhxpnLkq2X0IrhjPqMlY3clI2RxYy0
            laWZlJmSke+S5JmNnUuVm5GlnUkAAI3tmY6Zj5FPiqWZjJluAACZbJa7mW0AAJV5mW+ZcJlxk36ZXedH+oCT/OdJ50aRU5lf
            mWCUqoz2mFqZYZjyl2GK5pTQk9qY8Zj1AACQnJfMmPSMepLimOf6dZXtkmyY44yRAACY4JjomOKXz5jpmGCUbwAAlVWY5gAA
            le4AAIm0jFeRo4nimOr6duKp4qr6YY9y4qfipfpzmNeY0Ppv4p/6cgAAmNMAAJjMiqT6cYufmNKIy5jKAAD6cJfh5USOmJLP
            mMuUlpJBmMjlTuVGi8LlSJKHiMqS4Y9ajI+YwZe8ioYAAJRD+mqVwIxi+micjpii6e4AAJKG6e+TvOns6eue6J9En0OYa4mo
            6dbp0unQ6c+VteBViV/gVOBW6dqX65eLjkfoueBZk2TouOWrgaGBoJnUlceQl+i2kUya1+fykmTn7OfxifOWwY/rkrbn8+fw
            l+mBmIFOjNj67PvK+8TnzPvGnt+e2Oftj4ae5efLnuPnypCSkefm0ebSm7rm1JGhjejm04rk5Lrm1uSw5tWP2+a0kfvljOS8
            5YjkrpSciemNi5is5rXmbwAA5nDmbuSsjNbktJdf5LvktY6PlEaLluSzlvORaZCF5mT7pJVYiWmQZpKQj9jl4ZdUlMP69eXi
            5ePlqQAAleLl5OWtjb7lsOWvlLgAAJ2W5aeWzOV9kKDle+V+lWeU2OWCil6Q1OWBjs3m3eV85YDlRYpxkUXm3uVJjkaQZIxP
            lvLhz5b3j5LkwpO44c7hzeTHjoqSdgAA5MSWR+TKiN7kaeRqiVCbWORriN3j8pV3kl+QiePFm1kAAJtUlHfjxpHZiaXjxwAA
            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
            lbyb8Id+h4+HjoeNh1CHUYdSh1OBqYGqgaiBqw==
          `);
      }

      /* **************************************** */

      function createImgWithBase64(b64s, id) {
          const priority = 'important';
          const img = document.createElement('img');
          if (id != undefined)
              img.setAttribute('id', id);
          img.setAttribute('class', 'b64img');
          img.setAttribute('src', 'data:image/gif;charset=utf-8;base64,' + b64s);
          img.style.setProperty('margin', '0', priority);
          img.style.setProperty('padding', '32px', priority);
          img.style.setProperty('image-rendering', 'pixelated', priority);
          return img;
      }

      function checkText(message) {
          const S = GenQRCodeType;
          const msglen = message.length;

          const error = document.getElementById('error');
          while (error.firstChild)
              error.removeChild(error.firstChild);
          if (msglen == 0) {
              error.innerText = '';
              return;
          }

          const chkcp932 = ((c) => ((c.ucs < 0x80) || (c.cp932 != undefined)));
          const charlist = S.makeCharInfoList(message);
          const errlist = [...Array(msglen)].map((_, i) => chkcp932(charlist[i]));
          if (!errlist.reduce(((p, c) => p || !c), false)) {
              error.innerText = message;
              return;
          }

          const appendSpan = function(msg, flg) {
              const span = document.createElement('span');
              if (!flg) {
                  span.style.setProperty('color', '#0cc');
                  span.style.setProperty('background-color', '#c0c');
              }
              span.innerText = msg;
              error.append(span);
          }

          let last = errlist[0];
          let count = 1;
          let fcount = 0;
          for (let i = 1; i < msglen; i++) {
              const err = errlist[i];
              if (!err)
                  fcount++;
              if (last == err) {
                  count++;
                  continue;
              }
              if (!count)
                  continue;
              appendSpan(message.slice(i - count, i), last);
              last = err;
              count = 1;
          }
          if (count != 0)
              appendSpan(message.slice(msglen - count), last);
      }

      function onUpdate() {
          const tagMicro = document.getElementById('micro');
          const use_micro = tagMicro.checked;

          const tagScale = document.getElementById('scale');
          const qr_scale = tagScale.value;

          if (qr_scale < 1 || 10 < qr_scale)
              return;

          document.getElementById('m1tr').hidden = !use_micro;

          const inp = document.getElementById('qrinp');
          const message = inp.value;
          checkText(message);

          let iso_encode = new Array(5);
          let jis_encode = new Array(5);

          const qrmessage = new GenQRCode(message);
          if (message.length) {
              const sizelist = (use_micro
                                ? GenQRCodeType.SizeListAll
                                : GenQRCodeType.SizeListNormal);
              iso_encode = qrmessage.autoEncode({ size: sizelist, jis: false }, qr_scale);
              jis_encode = qrmessage.autoEncode({ size: sizelist, jis: true }, qr_scale);
          }

          for (let i = 0; i < 5; i++) {
              const tagType = document.getElementById('iqrtype' + i);
              const tagSize = document.getElementById('iqrsize' + i);
              const tagCorrect = document.getElementById('icorrect' + i);

              while (tagCorrect.firstChild)
                  tagCorrect.removeChild(tagCorrect.firstChild);

              const enc = iso_encode[i];
              if (enc == undefined) {
                  tagType.innerText = '';
                  tagSize.innerText = '';
                  continue;
              }
              tagType.innerText = enc.type.name;
              tagSize.innerText = '' + enc.type.size + '×' + enc.type.size;
              tagCorrect.append(createImgWithBase64(enc.base64gif));
          }

          for (let i = 0; i < 5; i++) {
              const tagType = document.getElementById('jqrtype' + i);
              const tagSize = document.getElementById('jqrsize' + i);
              const tagCorrect = document.getElementById('jcorrect' + i);

              while (tagCorrect.firstChild)
                  tagCorrect.removeChild(tagCorrect.firstChild);

              const enc = jis_encode[i];
              if (enc == undefined) {
                  tagType.innerText = '';
                  tagSize.innerText = '';
                  continue;
              }
              tagType.innerText = enc.type.name;
              tagSize.innerText = '' + enc.type.size + '×' + enc.type.size;
              tagCorrect.append(createImgWithBase64(enc.base64gif));
          }
      }

      document.querySelector('.micro').addEventListener('change', () => onUpdate());
      onUpdate();

      /* **************************************** */

    </script>
  </body>
</html>
